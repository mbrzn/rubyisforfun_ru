## Тестирование

Перед тем как мы познакомимся с тестированием, необходимо определиться, а что же такое тестирование. Это понятие достаточно широкое, а следовательно, могут существовать разные типы тестов.

Например, перед тем как настоящий инженер захочет послушать только что собранный из радиодеталей приемник, он быстро включит и выключит питание, чтобы посмотреть, не пойдет ли дым, не допущена ли где-нибудь фундаментальная ошибка. Такое тестирование называют `smoke-тестами` (smoke — дым). Затем инженер может приступить к «happy path» (дословно: «счастливый путь») тесту: включить приемник и посмотреть, идет ли звук и настраивается ли он на частоту хотя бы какой-нибудь радиостанции.

Перед запуском в продажу могут быть другие тесты. Например, нагрузочные: посмотреть, как приемник расходует батарею. А также тесты на качество сборки, на стабильность работы и т.д. Количество и глубина этих тестов зависят от требований. Делаем ли мы радиоприемник для розничной продажи или это военный образец? Ответы на эти фундаментальные вопросы определяют, какое именно тестирование нам нужно.

Похожая картина наблюдается и при разработке программ. Существует большое количество тестов для программ: ручные тесты, автоматизированные, юнит-тесты (модульные тесты), интеграционные тесты, нагрузочные. Чтобы познакомиться со всеми типами тестов, потребуется не один день. Мы рассмотрим тесты, с которыми чаще всего встречается программист: это юнит-тесты (`unit tests`, от англ. «unit» — модуль или часть). Что же такое юнит-тест и зачем он нужен?

Не так давно про тесты никто не думал. Программы создавали в текстовом редакторе, проверяли их работу и сразу же запускали (или отправляли своим клиентам на дискетах, CD-ROM'ах, а позднее и через Интернет). Если возникала какая-то ошибка, то ее исправляли. Таким образом, в новой версии (новом релизе) программы могло быть исправлено несколько ошибок.

Но сложность программ возрастала. Возрастало и количество разработчиков в командах. Нередко получалось так, что небольшое, казалось бы, улучшение вызывает ошибку. Эти ошибки, конечно, отлавливались командой ручных тестировщиков. Но от времени появления ошибки до момента ее выявления могло пройти несколько дней.

Поэтому возник вопрос о выявлении ошибок на более ранних этапах. Если существует какая-то часть программы, можно ли каким-то образом хотя бы сделать «защиту от дурака»? По аналогии с реальной жизнью: вы выходите из дома и знаете, что утюг и газовая плита выключены, но на всякий случай вы делаете то, что называется `double check` (двойная проверка). В 99 % случаев все будет так, как вы ожидаете, но в 1 % случаев эта двойная проверка даст положительный результат. Тем более цена двойной проверки очень мала.

В программировании есть что-то подобное, но:

* вместо проверки утюга и газовой плиты проверяется множество частей разной программы (например, один небольшой авторский проект [LibreTaxi.org](https://libretaxi.org/) содержит более 500 тестов);
* вместо проверки только один раз проверка происходит после каждого изменения.

Согласитесь, что это удобно: разработчик изменил программу, запустил тесты и проверил, что ничего фундаментального не сломалось. Если сломалось, то тут же исправил. В итоге от появления ошибки до момента ее выявления прошли минуты, но никак не дни (запуск 500 тестов занимает около двух минут). Получается, что на относительно небольшом проекте на каждые 100 изменений будет запущено по 500 тестов на каждое изменение, что в общей сложности дает 50 тысяч запусков разных тестов. Этот подход позволил значительно улучшить качество написанных программ. Однако у юнит-тестирования есть и недостатки.

Во-первых, вместе с написанием кода программы программисты также должны писать тесты. Несмотря на то что тесты писать легче, все равно необходимо уделять этому какое-то время. Для создания хороших тестов необходимо иметь знания фреймворков для юнит-тестирования, знания общепринятых подходов и какой-то минимальный опыт.

Во-вторых, юнит-тестирование никогда не покрывает абсолютно все участки кода. Десять конструкций `if...else` уже дают 1024 (двойка в десятой степени) возможных варианта выполнения вашей программы. В некоторых проектах используют такое выражение, как «покрытие кода» (`code coverage`), которое выражается в процентах. Например, говорят: *«code coverage для нашего проекта составляет 80 %»* (при этом это является предметом гордости). На самом деле вопрос в том, как считаются эти проценты. Да, отдельные модули могут быть покрыты тестами. Но даже 100%-ное покрытие не является панацеей от абсолютно всех ошибок: возможных вариантов выполнения программы всегда во много раз больше, чем тестов, которые может написать человек.

В-третьих, существует особенность, о которой редко говорят. Юнит-тесты обычно пишут сразу после написания какого-либо кода. Но на начальном этапе программный дизайн функциональности обычно еще не зафиксирован.

Как художник перед написанием полотна рисует этюды, так и программист чаще всего (порой даже неосознанно) сначала делает работоспособный набросок. Этот набросок потом может меняться, ведь со временем мысль в голове имеет свойство оформляться в более изящные формы. Так почему какая-то часть программы не может быть улучшена сразу после того, как она была написана в текстовом редакторе?

Юнит-тесты фиксируют дизайн программы на этапе, когда дизайн еще достаточно свеж и может поменяться. Если поспешить с написанием юнит-тестов, то есть вероятность того, что тесты нужно будет переписывать.

Но, несмотря на все недостатки, юнит-тестирование оказало неоценимый вклад в развитие индустрии программных продуктов. Юнит-тестирование является стандартом в индустрии, и абсолютно для каждого языка программирования существует фреймворк для создания тестов (очень часто таких фреймворков существует сразу несколько). В нашей книге мы рассмотрим наиболее популярный фреймворк для языка Руби, который называется *Rspec*.
