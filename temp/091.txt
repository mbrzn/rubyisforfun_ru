## RSpec

Совершенно нет необходимости рассматривать стандартную библиотеку для тестирования MiniTest, т.к. очень высока вероятность, что вы будете использовать не стандартную библиотеку, а очень популярный фреймворк, который называется RSpec. В [списке инструментов для тестирования](https://github.com/markets/awesome-ruby#testing) он занимает первое место, [статистика использования](https://www.ruby-toolbox.com/categories/testing_frameworks) тоже это подтверждает:

{width=100%}
![Фреймворки для тестирования Ruby, Rspec — самый популярный](images/091-testing-frameworks.png)

Нужно отметить, что существует множество мнений по поводу лучшего фреймворка для создания тестов. Например, один из создателей фреймворка Rails DHH не любит RSpec, о чем не стесняется говорить:

> *RSpec раздражает меня эстетически: без ощутимой выгоды в обмен на сложность, которую он привносит в юнит-тесты*.

[DHH в Twitter](https://twitter.com/dhh/status/52807321499340800)

Но Руби-сообщество придерживается другого мнения. Хотя и с мнением DHH можно согласиться: когда тесты разрастаются и начинаются умные (`smart`) трюки RSpec’а, то тесты на самом деле становятся менее читаемы. Это чем-то похоже на спортивную машину, которая едет по загруженному шоссе, постоянно перестраивается, но в итоге все равно едет в общем потоке. Поэтому иногда лучше быть не smart, а simple (проще) и писать более понятные тесты.

Плюс изначальная конфигурация RSpec может занять какое-то время у начинающего программиста. Но хорошая новость в том, что этот инструмент уже прошел фазу взросления, и на подавляющее большинство проблем, с которыми вы можете столкнуться, уже будет готовый ответ в Интернете.

На практике качество тестов в проекте очень зависит от команды. Не важно, каким именно инструментом вы пользуетесь: если бы существовал инструмент, который решает все проблемы, то ему не было бы цены. И вопрос читаемых тестов — это не вопрос инструмента, а вопрос баланса smart vs simple.

Основой RSpec является т.н. DSL — Domain Specific Language («предметно-ориентированный язык»). Само название говорит о том, что это какой-то язык, созданный специально для описания каких-то предметов.

Это, можно сказать, особый синтаксис, который появляется в языке после установки gem’a `rspec`. Помимо стандартных ключевых слов, появляются новые: `describe`, `it`, `let`, `before`, `after`. В этой книге мы не рассматривали, как именно работает механизм DSL. Для наших целей пока достаточно знать, что этот механизм позволяет создавать свой синтаксис внутри языка Руби.

Попробуем установить и настроить RSpec с нуля и написать первый тест. Для начала установим последнюю стабильную версию Руби. Для этого введем команду `rvm list known`, она покажет список доступных версий языка для установки. Нас интересует версия `MRI` (Matz's Ruby Interpreter, версия языка от создателя языка Руби Юкихиро Мацумото, эта версия является основной). Для установки достаточно ввести:

{line-numbers: false}
```
$ rvm install 2.7.0
```  

Или любую другую версию без суффикса `-preview`. После этого создадим каталог приложения и «закрепим» версию Руби за этим приложением:

{line-numbers: false}
```
$ mkdir rspec_demo
$ cd rspec_demo
$ echo "2.7.0" > .ruby-version
```

Проверим, что установленная версия Руби соответствует ожидаемой (ваш вывод может немного отличаться):

{line-numbers: false}
```
$ ruby -v
ruby 2.7.0p0 (2019-12-25 revision 647ee6f091) [x86_64-darwin16]
```

Если изменения не были «подхвачены», необходимо выйти и снова войти в каталог:

{line-numbers: false}
```
$ cd ..
$ cd rspec_demo
```

Раньше мы устанавливали gem’ы (дополнительные библиотеки) с помощью команды `gem install …`, но полезно где-то держать список всех необходимых gem’ов для вашего приложения. Для этих целей есть специальный файл, который называется *Gemfile*. Лучше создать его с помощью команды

{line-numbers: false}
```
$ bundle init
```

*Gemfile* будет выглядеть следующим образом:

{line-numbers: false}
```
# frozen_string_literal: true

source "https://rubygems.org"

git_source(:github) {|repo_name| "https://github.com/#{repo_name}" }

# gem "rails"
```

Теперь необходимо установить rspec. Это можно сделать при помощи команды `gem install rspec`, но раз уж мы договорились держать все в одном месте, изменим *Gemfile* на следующий:

{line-numbers: false}
```
source "https://rubygems.org"
gem "rspec"
```

И введем команду bundle («связка», «связать»):

{line-numbers: false}
```
$ bundle
Fetching gem metadata from https://rubygems.org/...
Resolving dependencies...
...
Fetching rspec 3.9.0
Installing rspec 3.9.0
Bundle complete! 1 Gemfile dependency, 7 gems now installed.
Use `bundle info [gemname]` to see where a bundled gem is installed.
```

Если вы посмотрите на текущую директорию, то увидите файл `Gemfile.lock`. Этот файл был создан автоматически, не рекомендуется менять его вручную. Он указывает, какие именно версии gem’ов были использованы для вашего приложения. Как и все в этом мире, gem’ы обновляются и могут менять версии. Не факт, что следующая версия будет совместима с предыдущей. Но вы же хотите, чтобы ваша программа работала через 5—10 лет? Поэтому мы «локаем» (от слова «lock» — «замок») ее на определенные версии gem’ов, и в будущем автоматического обновления gem’ов не будет. Не переживайте, мы всегда сможем обновить gem’ы вручную, когда мы этого захотим.

В директории вашего приложения должно быть три файла: `.ruby-version`, `Gemfile`, `Gemfile.lock` (воспользуйтесь командой `ls -a`, т.к. все файлы, начинающиеся с точки, не выводятся с помощью команды `ls`). Но возникает вопрос: если rspec был установлен, то куда?

Все верно, когда мы ввели команду `bundle`, пакет `rspec` был скачан из Интернета и размещен где-то в вашей файловой системе. Команда `gem which rspec` поможет вам увидеть точный путь, но знать точный путь обычно никогда не требуется. Все остальные программисты вашей команды будут также вводить `bundle` и на основе трех файлов смогут «воссоздать» точно такую же среду исполнения, какая сейчас существует на вашем компьютере, с точно такими же gem’ами. Правда, может отличаться номер патча. Например, версия Руби «ruby 2.5.1p57» согласно [SEMVER](www.semver.org) говорит о том, что патч в Руби-версии «2.5.1» — это единица. Но метка «p57», по сути, тоже означает номер патча: пятьдесят седьмой патч. Это, скажем так, тоже патч, но еще менее значимый. Какие-то очень незначительные изменения, исправление багов, улучшение безопасности. Звучит сложно? Но за это нам и платят деньги!

Команда `rspec --help` поможет определить, что делать дальше: нас интересует команда `rspec --init`:

{line-numbers: false}
```
$ rspec --init
  create   .rspec
  create   spec/spec_helper.rb
```

Было создано два файла (`.rspec` и `spec_helper.rb`) и одна директория `spec`. Теперь можно поговорить о том, что такое «spec». Это то же самое, что и тест. Это слово образовано от другого слова: «specification» (спецификация). По-русски иногда говорят «спек» или «спеки».

Файл `spec_helper.rb` достаточно объемный (порядка сотни строк), но по большей части это комментарии. Этот файл является вспомогательным и служит для настройки инструмента «rspec». Настраивать на данном этапе мы ничего не будем, поэтому оставим все настройки по умолчанию. Посмотрим на структуру нашего приложения:

{width=50%}
![Структура приложения без какого-либо «полезного» кода](images/091-files.png)

Что видно по этому рисунку? Программа еще не написана, но уже существует 5 файлов! Два файла являются т.н. dot-файлами (dotfiles, начинаются с точки). Есть файл с подчеркиванием (`snake_case`), есть файл с дефисом (`kebab-case`). Есть файлы, начинающиеся с большой буквы, есть файлы, начинающиеся с маленькой буквы. Есть файлы с расширением, есть без. Остается только сказать, что мы живем не в идеальном мире, а перфекционисты в программировании могут почувствовать себя не очень уютно.

Давайте напишем какой-нибудь «полезный» код, а потом покроем его тестами. И тут сразу же нужно сделать отступление. В сообществе разработчиков не утихают дебаты по поводу правильного подхода: что нужно делать сначала?

* Писать полезный код, а потом тесты?
* Или же сначала создавать тесты, а потом код? (т.н. Test Driven Development, TDD).

На сайте Youtube есть видео дебатов DHH (одного из создателей фреймворка Rails), Кента Бека (основателя методологии TDD) и Мартина Фаулера (известного автора трудов по основам объектно-ориентированного программирования и проектирования). Авторы этой книги солидарны с DHH и придерживаются мнения, что сначала нужно написать код, а потом покрывать существующий код тестами. 

Наш «полезный» код уже нам знаком: 

{line-numbers: false}
```ruby
def total_weight(options={})
  a = options[:soccer_ball_count] || 0
  b = options[:tennis_ball_count] || 0
  c = options[:golf_ball_count] || 0
  (a * 410) + (b * 58) + (c * 45) + 29
end

x = total_weight(soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1)
```

Мы рассматривали этот метод, когда считали общий вес заказа. Выше мы умножаем количество футбольных мячей `a` на вес каждого футбольного мяча (410 грамм), количество мячей для тенниса `b` на вес каждого мяча для тенниса (58 грамм), количество мячей для гольфа `c` на вес каждого мяча для гольфа (45 грамм) и прибавляем вес коробки (29 грамм).

Сейчас с этим методом все в порядке. Но почему именно этот метод стоит покрыть тестами? Чтобы ответить на этот вопрос, подумаем, что может пойти не так.

Во-первых, речь идет о деньгах — о стоимости посылки. Там, где деньги, там нужен точный расчет и нужна надежность. Какой-нибудь программист через год или два может заглянуть в этот метод и добавить новую функциональность. Например, новый тип мячей. Чтобы убедиться в том, что ничего не сломано, нужно хотя бы запустить этот метод и сравнить результат с ожидаемым. Но лучше делать это автоматически.

Во-вторых, кто-то может посчитать, что конструкция `|| 0` лишняя. Это мнение имеет право на существование, т.к. следующий код вполне работоспособен (попробуйте запустить в `pry`):

{line-numbers: false}
```ruby
def total_weight(options={})
  a = options[:soccer_ball_count]
  b = options[:tennis_ball_count]
  c = options[:golf_ball_count]
  (a * 410) + (b * 58) + (c * 45) + 29
end

x = total_weight(soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1)
```

Но только до той поры, пока код вызывается со всеми параметрами. Когда один из них отсутствует, будет выдана ошибка:

{line-numbers: false}
```
$ pry
...
x = total_weight(soccer_ball_count: 3, tennis_ball_count: 2)
NoMethodError: undefined method `*' for nil:NilClass
from (pry):12:in `total_weight'
```

Хороший тест не допустит этой ошибки.

В-третьих, представьте какой-нибудь более сложный сценарий. Например, если общий вес мячей больше определенного значения, то требуются две коробки. Или мы знаем, что при покупке хотя бы одного мяча для тенниса в коробку кладется рекламный буклет весом 25 грамм.

Конечно, можно было бы обойтись и без тестов. Достаточно написать правильный метод, проверить его вручную (например, в `pry`) и использовать в приложении. Но согласитесь, что неплохо бы было дать другим программистам возможность проверить написанный вами код. А еще лучше сделать так, чтобы этот код был представлен в общем наборе тестов, среди всех других проверок, чтобы с помощью одной консольной команды можно было запустить все тесты сразу и убедиться, что все в порядке.

Добавим в наше приложение одну директорию `lib` и два файла: `shipment.rb` и `app.rb`:

{width=40%}
![Добавление дополнительных файлов в проект](images/091-files2.png)

`app.rb` будет выглядеть следующим образом:

{line-numbers: false}
```ruby
require './lib/shipment'

x = Shipment.total_weight(soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1)
puts x
```

`lib/shipment.rb` будет содержать упомянутую выше функцию, но код будет представлен в виде модуля:

{line-numbers: false}
```ruby
module Shipment
  module_function

  def total_weight(options={})
    a = options[:soccer_ball_count] || 0
    b = options[:tennis_ball_count] || 0
    c = options[:golf_ball_count] || 0
    (a * 410) + (b * 58) + (c * 45) + 29
  end
end
```

Можно было бы создать класс и объявить метод в виде метода класса `self.total_weight`, но [не рекомендуется создавать классы](https://github.com/rubocop-hq/ruby-style-guide#modules-vs-classes), когда мы не собираемся создавать их экземпляры. Поэтому мы ограничимся модулем и специальным синтаксисом `module_function`.

При запуске `app.rb` на экран выводится вес отправления:

{line-numbers: false}
```
$ ruby app.rb
1420
```

Выше мы разбили программу на две части (на два юнита): часть, которая содержит логику `shipment.rb`. И часть, которая вызывает логику `app.rb`. Мы создадим тест для первого юнита, `shipment.rb`, который содержит основную логику. Второй юнит пока не является чем-то сложным, поэтому покрывать тестом мы его не будем.

Добавьте в директорию `spec` файл `shipment_spec.rb`:

{width=40%}
![Добавление shipping_spec.rb](images/091-files3.png)

со следующим содержимым:

{line-numbers: false}
```ruby
require './lib/shipment'

describe Shipment do
  it 'should work without options' do
    expect(Shipment.total_weight).to eq(29)
  end
end
```

И запустите тесты (параметры устанавливают форматирование в значение `d` — documentation, в этом случае rspec выводит имена тестов):

{line-numbers: false}
```
$ rspec -f d

Shipment
  should work without options

Finished in 0.00154 seconds (files took 0.09464 seconds to load)
1 example, 0 failures
```

Тест отлично отработал, но что же произошло в программе? Давайте разберемся. Вот код программы с комментариями:

{line-numbers: false}
```ruby
# подключаем юнит
require './lib/shipment'

# специальный синтаксис, который дословно говорит:
# "описываем Shipment (отправление)"
describe Shipment do

  # специальный синтаксис, который дословно говорит:
  # "это должно работать без опций"
  # (то, что в кавычках, - это строка, мы сами её пишем, слово "it" служебное)
  it 'should work without options' do

    # ожидаем, что общий вес отправления будет равен 29 (eq от англ."equal")
    expect(Shipment.total_weight).to eq(29)
  end
end
```

Согласитесь, что код выглядит не вполне обычно. То, что вы видите выше, — это т.н. rspec DSL (Domain Specific Language — язык предметной области). Он работает только в rspec. Давайте добавим еще один тест и посмотрим на результат:

{line-numbers: false}
```ruby
require './lib/shipment'

describe Shipment do
  it 'should work without options' do
    expect(Shipment.total_weight).to eq(29)
  end

  it 'should calculate shipment with only one item' do
    expect(Shipment.total_weight(soccer_ball_count: 1)).to eq(439)
    expect(Shipment.total_weight(tennis_ball_count: 1)).to eq(87)
    expect(Shipment.total_weight(golf_ball_count: 1)).to eq(74)
  end
end
```

Результат:

{line-numbers: false}
```
$ rspec -f d

Shipment
  should work without options
  should calculate shipment with only one item

Finished in 0.00156 seconds (files took 0.09641 seconds to load)
2 examples, 0 failures
```

Что произошло выше? «It should calculate shipment with only one item» дословно переводится как «это должно рассчитывать отправление только с одной вещью». Другими словами, как раз то, что мы желаем проверить: код должен работать в тех случаях, когда программист передает только 1 аргумент в функцию `total_weight`. Кстати, вместо непонятных цифр 439, 87, 74 лучше написать ожидаемый результат в виде сложения. В будущем, возможно, потребуется заменить 29 на какое-то другое значение, да и вообще, полезно иметь возможность понять, откуда взялись эти цифры:

{line-numbers: false}
```ruby
expect(Shipment.total_weight(soccer_ball_count: 1)).to eq(410 + 29)
expect(Shipment.total_weight(tennis_ball_count: 1)).to eq(58 + 29)
expect(Shipment.total_weight(golf_ball_count: 1)).to eq(45 + 29)
```

Давайте подробнее разберем строку

{line-numbers: false}
```ruby
expect(something).to eq(some_value)
```

которая также может быть представлена как

{line-numbers: false}
```ruby
expect(something).to be(some_value)
```

О разнице между `eq` и `be` — немного ниже. Эта строка похожа на предложение в английском языке. Например, мама говорит мальчику: «Son, when you go to school, I expect you to be a good boy» («Сынок, когда ты идешь в школу, я ожидаю, что ты будешь хорошим мальчиком»). На языке RSpec DSL это может быть записано следующим образом:

{line-numbers: false}
```ruby
expect(son).to be(a_good_boy)
```

Или немного иначе:

{line-numbers: false}
```ruby
expect(son).not_to be(a_bad_boy)
```

Если бы мы записывали программу на чистом Руби, то мы, скорее всего, написали бы что-то вроде:

{line-numbers: false}
```ruby
if son != a_good_boy
  panic
end
```

Но RSpec дает нам возможность записать все в виде одной строки и в более естественном (с точки зрения RSpec) виде. Под капотом там, конечно, используется обычная конструкция `if`. Другими словами, в тестах мы не пишем `if`, а сообщаем о наших ожиданиях. Мы не используем императивный стиль, а используем декларативный. Мама не говорит мальчику, что конкретно делать («не обижай девочек», «учись хорошо»), она говорит, что она от него ожидает («будь хорошим»). Другими словами, это spec, спецификация, которая где-то задана и которой надо соответствовать.

Выражения типа `expect(son).to` и `expect(son).not_to` являются ожиданием (expectation). А выражения `eq(...)` (от слова «equal»), `be(...)` называют матчерами (matchers). Матчеры и ожидания бывают разных типов. Обычно ожидания могут принимать или вид выражения, или вид блока.

Выражение (expression) в ожидании используется, когда мы проверяем какое-то существительное или результат действия. Например: мальчик, вес мяча, вес посылки:

{line-numbers: false}
```ruby
expect(son).to be(a_good_boy)
expect(soccer_ball_weight).to eq(410)
expect(Shipment.total_weight(soccer_ball_count: 1)).to eq(439)
```

Блоки в ожидании используются, когда требуется или проверить что-то во время операции, или сделать какое-то измерение. Например: проверить, что метод выдает исключение, если запущен с определенными параметрами; проверить, что метод меняет состояние экземпляра класса, например добавляем товар в корзину, а общее количество элементов в корзине увеличилось на один. Если в случае выражений мы просто помещали их в скобки, то в случае с блоками мы передаем их в фигурных скобках:

{line-numbers: false}
```ruby
expect { Shipment.total_weight(ford_trucks: 100) }.to raise_error
expect { some_order.add(item) }.to change { order.item_count }.by(1)
```

Синтаксис является немного необычным и требует привыкания. Ожидания и стандартные матчеры доступны на [официальном сайте](https://relishapp.com/rspec/rspec-expectations/docs/built-in-matchers). Хочется заметить, что из практики программирования этого набора обычно достаточно.

У нас нет задачи дать полную справку по rspec, но следует упомянуть о различии матчеров `eq` и `be`. `Be` означает «быть», т.е. быть в смысле «точно вот этим». А `eq` означает «равен» (`equals`). То есть не обязательно быть точно таким же, но нужно равняться. Например, надписи на заборах из трех букв обычно равны (`eq`), но каждая из них уникальна по-своему, поэтому нельзя применить к ним матчер `be`. Ведь надпись может быть нарисована разной краской, разным размером и т.д.

Так как все в Руби — объект, то это важно. Например, переменные `a` и `b` ниже равны, но их идентификаторы разные, т.к. это разные объекты и они расположены в разных областях памяти:

{line-numbers: false}
```
$ pry
> a = "XXX"
> b = "XXX"
> a == b
 => true
> a.__id__ == b.__id__
 => false
```

Давайте напишем еще один тест для нашей программы:

{line-numbers: false}
```ruby
  it 'should calculate shipment with multiple items' do
    expect(
      Shipment.total_weight(soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1)
    ).to eq(1420)
  end
```

Ради удобства чтения выражение, которое мы хотим проверить, было перенесено на отдельную строку. Результат выполнения всех тестов:

{line-numbers: false}
```
$ rspec -f d

Shipment
  should work without options
  should calculate shipment with only one item
  should calculate shipment with multiple items

Finished in 0.00291 seconds (files took 0.19016 seconds to load)
3 examples, 0 failures
```

Все это хорошо, но выше был дан пример тестирования «статического» метода, или метода класса (точнее модуля, что почти одно и то же), но не экземпляра. Заметьте, что мы нигде не создавали никакого объекта, а вызывали класс напрямую. В случае наличия объекта для тестирования все становится намного интереснее.

Можно долго рассказывать про rspec, и существуют [отдельные книги](https://leanpub.com/everydayrailsrspec) на эту тему, но самый лучший совет, который могут дать авторы: при написании программ старайтесь думать о том, как вы будете тестировать написанный вами код. Существует множество приемов, но наша задача — познакомить вас с синтаксисом и дать основы.

X> ## Задание 1
X> Попробуйте заменить 1420 выше на 1421 и посмотрите, что произойдет (тест не должен сработать).
>
X> ## Задание 2
X> Код файла `shipment.rb` был изменен: если в метод «total_weight» не переданы аргументы, генерируется ошибка (также говорят «выбрасывается исключение»):

{line-numbers: false}
```ruby
module Shipment
  module_function

  def total_weight(options={})
	raise "Can't calculate weight with empty options" if options.empty?
	a = options[:soccer_ball_count] || 0
	b = options[:tennis_ball_count] || 0
	c = options[:golf_ball_count] || 0
	(a * 410) + (b * 58) + (c * 45) + 29
  end
end
```

Измените тест таким образом, чтобы тест проверял, что ошибка на самом деле генерируется.
