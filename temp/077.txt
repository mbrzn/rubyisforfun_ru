## Полиморфизм и duck typing

В объектно-ориентированном программировании много замысловатых понятий и определений. Однако не все зарабатывающие программисты могут точно сказать, что же такое полиморфизм и что такое `duck typing`. Происходит это потому, что некоторые принципы с легкостью усваиваются на практике и часто откровение приходит потом: «ах, вот что такое полиморфизм!»

Давайте заглянем в словарь, чтобы разобраться с этимологией самого загадочного слова — «полиморфизм». Что это означает? Сайт wiktionary подсказывает: «*возможность существования чего-либо в различных формах*», биологическое: «*наличие в пределах одного вида резко отличных по облику особей, не имеющих переходных форм*». Другими словами, что-то похожее, но «резко отличное». Ничего себе!

Если рассматривать полиморфизм в программировании, то его можно проиллюстрировать известной шуткой. Брутальный байкер в кожаной куртке, весь в цепях, с огромной злой собакой вызывает лифт, открываются двери — в лифте дедушка и бабушка божий одуванчик. Байкер заходит в лифт и командует громким голосом: «сидеть!» Садятся трое: собака, бабушка и дедушка.

См. также отрывок видео из «[Полицейской академии](https://www.youtube.com/watch?v=Rq0FDVOTmcI)».

Что же произошло? Программист бы сказал, что у всех объектов одинаковый интерфейс. Объекты разные, но все объекты восприняли команду, которую отправил байкер: `obj.send(:sit)`, — и не выдали ошибки.

Для того чтобы сделать подобное в статически типизированных языках, необходимо на самом деле объявить интерфейс. Пример программы на C#:

{line-numbers: false}
```csharp
interface IListener {
    void Sit();
}

class Dog : IListener {
    public void Sit() {
        // ...
    }
}

class Human : IListener {
    public void Sit() {
        // ...
    }
}
```

Мы объявили интерфейс «слушатель». И собака с человеком реализуют этот интерфейс каким-то образом. Другими словами, мы можем приказать собаке сидеть: `dog.Sit()` — и приказать сидеть человеку: `human.Sit()`. Только в случае наличия интерфейса программа на C# будет работать. Точнее, байкер сможет обратиться к произвольному объекту, зная только его интерфейс и не зная точно, к кому именно он обращается (который называется «слушатель», «listener»).

Но в языке Руби интерфейсов нет. Это язык с динамической типизацией, и вместо интерфейсов в Руби есть `duck typing` (что переводится как «утиная типизация» — но так редко кто говорит, говорят в основном по-английски). `Duck typing` сводится к следующему простому принципу:

> If it walks like a duck, and it quacks like a duck, then it has to be a duck.
> (Перевод: если что-то ходит как утка и крякает как утка, то это утка и есть.)

Но какой же в этом смысл? А смысл в следующем. Если есть какие-либо классы, у которых есть одинаковые методы, то с точки зрения потребителя это одинаковые классы. Другими словами, с точки зрения байкера в шутке выше человек и собака — это одно и то же, потому что объекты реализуют одинаковый интерфейс с одним методом `sit`. Сама утка может быть реализована следующим образом:

{line-numbers: false}
```ruby
class Duck
  def walk
  end

  def quack
  end
end
```

Если мы реализуем два этих метода в собаке, то с точки зрения командира уток это будет утка. Командир будет приказывать собаке крякать, и она будет крякать. Так работают динамически типизированные языки (Руби, JavaScript, Python и т.д.). Пример программы:

{line-numbers: false}
```ruby
# Утка
class Duck
  def walk
  end

  def quack
  end
end

# Собака
class Dog
  def walk
  end

  def quack
  end
end

# Утиный командир, который дает команды
class DuckCommander
  def command(who)
    who.walk
    who.quack
  end
end

# Создадим утку и собаку
duck = Duck.new
dog = Dog.new

# Покажем, что утиный командир может командовать собакой
# и уткой и при этом не возникнет никакой ошибки
dc = DuckCommander.new
dc.command(duck)
dc.command(dog)
```

— Но зачем это все? — спросит читатель. — Это все сложно, какое этому может быть применение в реальной жизни? 

На самом деле это облегчает программы. Попробуем добавить в нашу программу с десятью роботами еще один класс — собаку. И представим, что собаке надо пройти из левого верхнего угла в нижний правый и не столкнуться с роботами. Если робот поймал собаку — игра окончена.

С чего начать? Во-первых, собака должна быть как-то иначе отображена на экране. Робот — это звездочка. Пусть у собаки будет символ `@`. Вспомним «интерфейс» робота (а точнее `duck typing`), какие в нем реализованы методы? `Up`, `down`, `left`, `right`, `x`, `y`. Это подходит и для собаки. Чтобы различать робота и собаку, добавим еще один метод, `label`:

{line-numbers: false}
```ruby
class Robot
  # ...

  def label
    '*'
  end
end

class Dog
  # ...

  def label
    '@'
  end
end
```

В итоге у нас получилось два «совершенно одинаковых» класса и в то же время разных. Помните, что такое полиморфизм? «*Возможность существования чего-либо в различных формах*». Одинаковы классы тем, что они реализуют единый интерфейс, они одинаковы с точки зрения потребителя этих классов. Разные они в том плане, что называются они по-разному и содержат разную реализацию. Робот может ходить во все стороны и выглядит как звездочка. Собака может ходить только слева направо и сверху вниз (см. код ниже) и выглядит как `@`.

Давайте немного изменим программу, которую мы уже писали выше, и посмотрим, что такое полиморфизм на практике.

{line-numbers: false}
```ruby
# Класс робота
class Robot
  # Акцессоры — чтобы можно было узнать координаты снаружи
  attr_accessor :x, :y

  # Конструктор, принимает хеш. Если не задан — будет пустой хеш.
  # В хеше мы ожидаем два параметра — начальные координаты робота,
  # если не заданы, будут по умолчанию равны нулю.
  def initialize(options={})
    @x = options[:x] || 0
    @y = options[:y] || 0
  end

  def right
    self.x += 1
  end

  def left
    self.x -= 1
  end

  def up
    self.y += 1
  end

  def down
    self.y -= 1
  end

  # Новый метод — как отображать робота на экране
  def label
    '*'
  end
end

# Класс собаки, тот же самый интерфейс, но некоторые методы пустые.
class Dog
  # Акцессоры — чтобы можно было узнать координаты снаружи
  attr_accessor :x, :y

  # Конструктор, принимает хеш. Если не задан — будет пустой хеш.
  # В хеше мы ожидаем два параметра — начальные координаты собаки,
  # если не заданы, будут по умолчанию равны нулю.
  def initialize(options={})
    @x = options[:x] || 0
    @y = options[:y] || 0
  end

  def right
    self.x += 1
  end

  # Пустой метод, но он существует. Когда вызывается,
  # ничего не делает.
  def left
  end

  # Тоже пустой метод.
  def up
  end

  def down
    self.y -= 1
  end

  # Как отображаем собаку.
  def label
    '@'
  end
end


# Класс «Командир», который будет командовать и двигать роботов
# и собаку. ЭТОТ КЛАСС ТОЧНО ТАКОЙ ЖЕ, КАК В ПРЕДЫДУЩЕМ ПРИМЕРЕ.
class Commander
  # Дать команду на движение объекта. Метод принимает объект
  # и посылает (send) ему случайную команду.
  def move(who)
    m = [:right, :left, :up, :down].sample
    # Вот он, полиморфизм! Посылаем команду, но не знаем кому!
    who.send(m)
  end
end

# Создать объект командира,
# командир в этом варианте программы будет один.
commander = Commander.new

# Массив из 10 роботов и...
arr = Array.new(10) { Robot.new }

# ...и одной собаки. Т.к. собака реализует точно такой же интерфейс,
# все объекты в массиве «как будто» одного типа.
arr.push(Dog.new(x: -12, y: 12))

# В бесконечном цикле (для остановки программы нажмите ^C)
loop do
  # Хитрый способ очистить экран
  puts "\e[H\e[2J"

  # Рисуем воображаемую сетку. Сетка начинается от -12 до 12 по X
  # и от 12 до -12 по Y
  (12).downto(-12) do |y|
    (-12).upto(12) do |x|
      # Проверяем, есть ли у нас в массиве кто-то с координатами x и y.
      # Заменили «any?» на «find» и записали результат в переменную
      somebody = arr.find { |somebody| somebody.x == x && somebody.y == y }

      # Если кто-то найден, рисуем label. Иначе точку.
      if somebody
        # ВОТ ОН, ПОЛИМОРФИЗМ!
        # Рисуем что-то, «*» или «@», но что это — мы не знаем!
        print somebody.label
      else
        print '.'
      end
    end

    # Просто переводим строку:
    puts
  end

  # Проверка столкновения. Если есть два объекта с одинаковыми
  # координатами и их «label» не равны, то, значит, робот поймал собаку.
  game_over = arr.combination(2).any? do |a, b|
    a.x == b.x && \
    a.y == b.y && \
    a.label != b.label
  end

  if game_over
    puts 'Game over'
    exit
  end

  # Каждый объект двигаем в случайном направлении
  arr.each do |somebody|
    # Вызываем метод move, все то же самое, что и в предыдущем
    # варианте. Командир не знает, кому он отдает приказ.
    commander.move(somebody)
  end

  # Задержка в полсекунды
  sleep 0.5
end
```

Несколько оговорок по поводу программы выше. Во-первых, чтобы собака примерно ходила по диагонали, размер поля был уменьшен до `25*25` (от −12 до 12). Во-вторых, класс `Commander` остался точно таким же. Он не изменился, потому что этот класс изначально подразумевал `duck typing` — «если это ходит вверх, вниз, влево, вправо, то мне не важно, кто это, робот или собака». В-третьих, мы использовали хитрый способ определения столкновения. Он был честно найден в Интернете по запросу «*ruby any two elements of array site:stackoverflow.com*» — часто программисту нужно только уметь найти правильный ответ!

Результат работы программы:

{line-numbers: false}
```
.........................
.........*...............
.........................
...........*.............
........@................
...............*.*.......
........*.....*..........
.........................
............*............
...*.....................
``` 

Демо: [https://asciinema.org/a/KsenHLiaRbTilZa081EhZSFXF](https://asciinema.org/a/KsenHLiaRbTilZa081EhZSFXF).

X> ## Задание 1
X> Удалите все комментарии в программе выше. Способны ли вы разобраться в том, что происходит?
>
X> ## Задание 2
X> Добавьте на поле еще 3 собаки.
>
X> ## Задание 3
X> Исправьте программу: если все собаки дошли до правого или нижнего края поля, выводить на экран «Win!».
