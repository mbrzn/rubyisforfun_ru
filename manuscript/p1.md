# Часть 1. Первые шаги
[[bat_install.sh|установить bat]]

Защитить файл журнала от перезаписи:
```bash
 1305  sudo chattr +a p1.md 
 1320  history | grep chattr >> p1.md
```
Поиск файлов
найти руби файлы на компьютере, полюбоваться их синтаксической формой
```bash
 1329  sudo find / -name '*.rb' | tail -10 | xargs bat 
 1332  history | grip 'xargs bat' >>p1.md
 1333  history | grep 'xargs bat' >>p1.md
```
>[!Note]
holy wars - святые войны

Интерактивная программа:
- выводит строку
- ждет ввода строки
- выводит строку
- ждет ввода
- и т.д.

```ruby
puts "How to translate ball?"
gets
puts "How to translate cap?"
gets
puts "How to translate cat?"
gets
puts "How to translate bat?"
gets
puts "How to translate ruby?"
gets
```

## Часть 2. Основы

### Все есть класс

```ruby
puts 12.class
puts Integer.class
puts Class.class
```
```terminal
Integer
Class
Class
```
>Говорят, что все в Руби — объект (Object). В результате любой операции получается объект. Каждый объект «*реализует метод*» `class`. Выражение «*реализует метод*» означает, что какой-то программист, разработчик языка Руби, сделал специальную небольшую подпрограмму, которую мы с вами можем запускать, если знаем имя этой подпрограммы. Чтобы вызвать подпрограмму для какого-либо объекта, нужно ввести точку и написать имя этой подпрограммы.
>Экземпляр класса Object - число 1 - являетя объектом, но не является классом


- экземпляр класса Class - объект Object - является классом
- объект класса Class - объект Class - является классом, т.е. подкласс 

```ruby
irb(main):012:0> 1.is_a?(Object)
=> true
irb(main):013:0> 1.is_a?(Class)
=> false
irb(main):014:0> Object.is_a?(Class)
=> true
irb(main):015:0> Class.is_a?(Class)
=> true
irb(main):016:0>
```
```ruby
irb(main):001:0> Class.is_a?(Object)
=> true
```

>[!Question] Как относятся понятия
Объект и Класс?

String нельзя складывать с Integer, полагается - операция применима только к объектам одного класса. Чтобы применить операцию печати объекта класса String к чужеродному объекту (класса Integer), его нужно преобразовать, привести к классу String.  Т.е. изготовить небывалый ранее объект - строку высосанную из пальца, в процессе размышлений о числе. Эта высосанная из пальца ассоциация cугубо субъективна - так захотел программист.
```ruby
# приведение строки к числу, а числа к строке
irb(main):001:0> age=gets
33
=> "33\n"
irb(main):002:0> puts "Age is " + ( age.to_i * 12 ).to_s + " monthes."
Age is 396 monthes.
=> nil
```
>[!Note] Здравствуйте, я ваш REPL
>Из начальных букв у нас получилось REPL — read evaluate print loop. То есть REPL — это такая программа, которая сначала читает, потом исполняет, потом печатает результат и затем начинает все сначала. Это понятие широко известно и используется не только в Руби. А в Руби REPL-программа называется irb (interactive ruby).

### Размер объекта

Объекту языка свойствена мера. Так объект типа String измеряется в символах:
```ruby
irb(main):014:0> "hello".size
=> 5
```

Объекту тип Integer свойственно имеряться в 8-и байтовых словах:
```ruby
# это число не вмещается в 64 бита:
irb(main):012:0> (2**64).size
=> 9
# ему нужно 9-ть слов
#
# а вот этому числу достаточно 8-и слов
irb(main):013:0> (2**63).size
=> 8
irb(main):009:0> 3.size
=> 8
# ... как и числу 3
```

### Интерполяция строк

Строки в двойных кавычках интерпретируются как символы печатной машинки - обычные и специальные (типа перевода каретки):
```ruby
irb(main):001:0> "Hello\n".chomp.size
=> 5
irb(main):002:0> "Hello".chomp.size
=> 5
```
Строки в одинарных кавычках для ruby - *не аналоговые*, не из печатной машинки, а *цифровые* - здесь нет понятия `специального символа`, здесь символы - это `байт`-ы:
```ruby
irb(main):003:0> 'Hello\n'.chomp.size
=> 7
```
##### Задание 2

> Напишите программу для подсчета годовой зарплаты. Пользователь вводит размер заработной платы в месяц, а программа выводит размер заработной платы в год. Допустим, что пользователь каждый месяц хочет откладывать 15 % своей зарплаты. Измените программу, чтобы она выводила не только размер заработной платы, но и размер отложенных за год средств. Измените программу, чтобы она выводила размер отложенных средств за 5 лет.
```ruby
puts "Input your month income:"
inc_m=gets.to_f
puts "If put 15% isurance, then:"
inc_y=inc_m*12
insr_y=inc_y*15/100
puts "\tyear income is #{inc_y}"
puts "\tyears insurance #{insr_y}"
puts "\t5 year income is #{inc_y*5}"
puts "\t5 years insurance is #{insr_y*5}"
```
```terminal
Input your month income:
45000
If put 15% isurance, then:
        year income is 540000.0
        years insurance 81000.0
        5 year income is 2700000.0
        5 years insurance is 405000.0
```

#### Bang!

Язык - суть именование адресов на объекты памяти:
- Оъект - это физические выключатели в микросхеме памяти, составляющие единство. Это единство и есть объект языка.
- Имя, переменная - это слово в словаре - хэш-таблице из человеческих слов (имен переменных) и адресов объектов в памяти машины.
- Адрес - это логический элемент, атом древовидной логической конструкции:
    - физические элементы машины изготовлены по древовидному чертежу
    - умозрение программиста оперирует абстракциями по древовидному чертежу
    - производитель машин и программист руководствуются конвенцией, соглашением - давайте будем использовать общую логико-математическую теорию (целостную систему рассуждений) для нашей общей коммерческой выгоды

Оператор `Bang!` проявляет объективность объекта (физическое тело, единица) и субъективность программиста:
- программист может называть объект так, как ему `удобно`
- объект же остается единицей (но не множеством)
    - объект один, а имен - множество

> [!Attention] Коробочка со значением и ссылка. 
> Две коробочки и их отношение.
> [[Максим @demimurych|Гений эффективности]] о переменных: [Почему ООП умирает | Стрим про языки программирования с @AsForJS - YouTube](https://youtu.be/mxquElJC_qM?t=857)

```ruby
irb(main):001:0> obj_name_1="СоСТОЯние ЕдИНСТВа ВЫКлючателей В МИКросХЕМе ПАмяти"
=> "СоСТОЯние ЕдИНСТВа ВЫКлючателей В МИКросХЕМе ПАмяти"
irb(main):002:0> obj_name_2=obj_name_1
=> "СоСТОЯние ЕдИНСТВа ВЫКлючателей В МИКросХЕМе ПАмяти"
irb(main):003:0> # Все то же единство физических выключателей можем именовать
=> nil
irb(main):004:0> # по-другому, вторым именем
=> nil
irb(main):005:0> # Спросим абстракцию: Что у тебя за душой?
=> nil
irb(main):006:0> puts obj_name_1
СоСТОЯние ЕдИНСТВа ВЫКлючателей В МИКросХЕМе ПАмяти
=> nil
irb(main):007:0> # Изменение абстракции равно изменению физического атома? Абстрация физически полезна?
=> nil
irb(main):008:0> puts obj_name_1.downcase!
состояние единства выключателей в микросхеме памяти
=> nil
irb(main):009:0> # Полезна - изменение физического атома налицо.
=> nil
irb(main):010:0> # Вопрос вопросов о мышлении: А вот за вторым именем объекта что-то независимое от оъекта есть?
=> nil
irb(main):011:0> puts obj_name_2
состояние единства выключателей в микросхеме памяти
=> nil
irb(main):012:0> # Нет, за вторым именем нет ничего физически иного в физически атомном.
=> nil
```

>[!Question] Основной вопрос философии
>Как второе имя вещи влияет на вещь?
>
>Не замысел ли программиста приговаривает вещь. Программист - судьба вещи?
#### Оператор присваивания суть объективность

Объективность программирования является в операторе "=", *отношение созидания*
- оператор "=" полагает отношение
    - физического объекта
    - духовной деятельности - сфера имен и мечт
    - бракосочетание души программиста и физического голема из глины

Писатель знака "=" творит миф для голема. Имена - имена ролей, которые будет играть голем в пьесе писателя-программиста.

>* Оператор присваивания **=** автоматически создаёт новый объект для переменной;
>* одинаковых значений может быть множество;
>* наименование каждой переменной уникально.

>[!Note] Сфера программирования
> Кажется, детонат, смысл, знак и символ - это и есть те
> понятия, которыми определяется деятельность пространства имен, пространство возможных пьес, сфера Витгенштейна.
> - [[lit/87.442 Модуль 1. Предмет логики]]
>- [[lit/87.442 Модуль 2. Логика терминов]]
>- [[Некоторые спорные размышления над работой Г. Фреге «Смысл и денотат»  Хабр]]

>[class String - Documentation for Ruby 3.4](https://docs.ruby-lang.org/en/master/String.html#method-i-chomp)
>Some String methods modify self. Typically, a method whose name ends with ! modifies self and returns self; often a similarly named method (without the !) returns a new string.
>`String#sub!`: One substitution (or none); returns self.
>`String#gsub!`: Zero or more substitutions; returns self.
>>s = 'hello'
>>s.gsub(/[aeiou]/, '*') # => "h*ll*"
>>chomp!

#### Загадка о замороженном литерале

Наличие комментария в программе, влияет на ее результат. Почему?
```ruby
# frozen_string_literal: true
a='aaa'
b='aaa'
puts a.object_id
puts b.object_id
```
```terminal
# если комментарий есть, то вывод:
60
60
# если комментария нет, то вывод:
60
80
# если комментарий есть, но в нем вместо true указано false, то вывод:
60
80
```
- [x] Значит, ruby понимает некторые коментарии как директивы
- [x] директива` frozen_`... устанавливает единственность или множественность объектов физических (в памяти, в микросхеме), создаваемых интерпретатором при чтении текста программы. Что имел в виду программист, указывая в программе строку 'aaa' дважды?
	- один физический объект?
	- два?
	- [x] Директива `frozen_`... указывает на тип умостроя автора программы программе.

### Блок

Оператор применяется к блоку в фигурных скобках. Всякий (!) метод применим к блоку.
>[!Question] Блок - объект?
Почему блок универсален?

```ruby
loop { print 'Рома ' }
```

- [x] Блок - не объект, а некое прилагаемое лишь. Блок сам по себе существовать не может.

Объект Integer передает в блок параметр - число i:
```ruby
sum=0
12.times do |i|
  sum=sum+i
  puts "sum = #{sum} i = #{i}"
end
```
Т.о. блок вообще - это некое прилагаемое к методу объекта, нечто методное.
###### Задание 2
>Измените программу из предыдущего задания со следующими условиями: человек берет дом не в рассрочку, а в кредит по ставке 4 % годовых на оставшуюся сумму. Для каждого года посчитайте, сколько денег нужно заплатить за этот год за использование кредита.
>Измените программу из предыдущего задания со следующими условиями: человек берет дом не в рассрочку, а в кредит по ставке 4 % годовых на оставшуюся сумму. Для каждого года посчитайте, сколько денег нужно заплатить за этот год за использование кредита.
```ruby
cost=500000
irb(main):026:1* period.times do |i|
irb(main):027:1*   puts "конец #{i+1}-го года: %% #{cost*( 1 - i.to_f/period.to_f )*0.04}"
irb(main):028:0> end
```
###### Задание 3

>Посчитайте количество денег (total), которые мы заплатим только в виде процентов по кредиту за 30 лет.
```ruby
irb(main):006:0> cost=500000
=> 500000
irb(main):007:0> sum_proc=0
=> 0
irb(main):008:0> period=30
=> 30
irb(main):009:1* period.times do |i|
irb(main):010:1*   sum_proc=sum_proc + cost*( 1 - i.to_f/period.to_f )*0.04
irb(main):011:1*   puts "конец #{i+1}-го года: %% #{sum_proc}"
irb(main):012:0> end
```

#### TrueClass и FalseClass

Знак вопроса в конце метода говорит лишь о том, что метод возвращает значение типа *Boolean* (в языке Руби нет отдельного типа для *Boolean*, поэтому это либо *TrueClass* тип, либо *FalseClass* тип). Другими словами, значение либо *true*, либо *false*. Например, метод, который определяет, беременна ли девушка, можно записать только со знаком вопроса в конце, потому что результат — или *true* (истина), или *false* (ложь). Часто такие методы начинаются со слова `is`:

```ruby
irb(main):002:0> (1.even?).class
=> FalseClass
irb(main):003:0> (1.odd?).class
=> TrueClass
irb(main):004:0>
```

Метод `even?` объекта `1` возвращает объект класса `FalseClass` - что означает *не принадлежать классу четных чисел*.
Результатом логического выражения является объект одного из двух классов, которые привычно ассоциируются с истиной и ложью:

```ruby
irb(main):001:0> 10%2==0
=> true
irb(main):002:0> 10%2!=0
=> false
irb(main):003:0> (10%2!=0).class
=> FalseClass
```

> Вывести на экран числа от 50 до 100.
> Вывести на экран числа от 50 до 100, и если число четное — рядом с ним написать `true`, если нечетное — `false`.

```ruby
irb(main):005:0> 50.upto(100) { |i| puts "#{i}" }
irb(main):004:0> 51.times { |i| puts "#{i+50}" }
```
Первое решение - буквальное выражение человеческого языка.

```ruby
irb(main):004:1* 50.upto(100) do|i|
irb(main):005:1*   puts "#{i} : " + "#{i.even?}"
irb(main):006:0> end
```

> Вы создаете веб-сайт для барбер-шопа. Выведите на экран все виды текстурного крема для волос. Каждый вид крема имеет два параметра, SHINE (блеск) и HOLD (стойкость). Каждый параметр представлен цифрой от 1 до 5.

```ruby
irb(main):012:1* 1.upto(up_shine) do |i|
irb(main):013:2*   1.upto(up_hold) do |j|
irb(main):014:2*     puts "SHINE #{i} / HOLD #{j}"
irb(main):015:1*   end
irb(main):016:0> end
```

## Ветвление

> Известно, что на Луне продают участки. Любой участок менее 50 квадратных метров стоит 1000 долларов. Участок площадью от 50 до 100 квадратных метров стоит 1500 долларов. От 100 и выше — по 25 долларов за квадратный метр. Напишите программу, которая запрашивает длину и ширину участка и выводит на экран его стоимость.
> Известно, что на Луне продают участки. Любой участок менее 50 квадратных метров стоит 1000 долларов. Участок площадью от 50 до 100 квадратных метров стоит 1500 долларов. От 100 и выше — по 25 долларов за квадратный метр. Напишите программу, которая запрашивает длину и ширину участка и выводит на экран его стоимость.
```ruby
puts "Цена луны #{1000} if s<50"
puts "Цена луны #{1500} if s>50 && s<100"
puts "Цена луны #{25}*s if s>=100"

puts "Input width:"
w=gets.chomp.to_f
puts "Input length:"
l=gets.chomp.to_f
s=w*l
puts "Цена луны #{1000}" if s<50
puts "Цена луны #{1500}" if s>50 && s<100
puts "Цена луны #{25*s}" if s>=100
```

> Напишите программу «иммигрант». Программа должна задавать следующие вопросы: «У вас есть высшее образование? (y/n)», «У вас есть опыт работы программистом? (y/n)», «У вас более трех лет опыта? (y/n)». За каждый положительный ответ начисляется 1 балл (переменную можно назвать score). Если набралось 2 или более баллов, программа должна выводить на экран «Добро пожаловать в США».

```ruby
score=0
puts "У вас есть высшее образование? (y/n)"
score=1 if gets.chomp.downcase == 'y'
puts "У вас есть опыт работы программистом? (y/n)"
score=score+1 if gets.chomp.downcase == 'y'
puts "У вас более трех лет опыта? (y/n)"
score=score+1 if gets.chomp.downcase == 'y'
puts "Добро пожаловать в США." if score >= 3
```

> Измените программу, чтобы она загадывала число от 1 до 1_000_000 (1 миллиона). Чтобы можно было угадать это число, программа должна сравнивать текущий ответ пользователя и искомое число: 1) если ответ пользователя больше, то программа должна выводить на экран «Искомое число меньше вашего ответа»; 2) иначе «Искомое число больше вашего ответа». Может показаться, что угадать это число невозможно, однако математический расчет показывает, что угадать число в этом случае можно не более, чем за 20 попыток.
> Напишите программу, чтобы она загадывала число от 1 до 1_000_000 (1 миллиона). Чтобы можно было угадать это число, программа должна сравнивать текущий ответ пользователя и искомое число: 1) если ответ пользователя больше, то программа должна выводить на экран «Искомое число меньше вашего ответа»; 2) иначе «Искомое число больше вашего ответа». Может показаться, что угадать это число невозможно, однако математический расчет показывает, что угадать число в этом случае можно не более, чем за 20 попыток.

```ruby
number=rand(1..1000000)
print 'Привет! Я загадал число от до 1000000, попробуйте угадать:'

loop do
  input=gets.to_i

  if input == number
    puts 'Правильно!'
    exit
  else
    if input > number
      print'Неправильно, искомое число меньше, попробуйте еще раз:'
    else
      print'Неправильно, искомое число больше, попробуйте еще раз:'
    end
  end
end
```
## Часть 3. Время веселья

### Тернарный оператор


###### Задание
>
> Запишите следующие примеры при помощи тернарного оператора.
```ruby
# Придут или не придут?
def friends_are_also_coming?
  1.upto(5) do |i|
    sleep 0.743
    rand(1..2) == 1 ? (print "Придут? ... ") : (print "Не придут...  ")
  end
  print "\r"
  return rand(1..2)==1 ? (2*2==4) : (2*2==5)
end

# Придут !
def go_party
  loop do
    1.upto(4) do |i|
      rand(1..2) == 1 ? (print "Ураааааааа ! ") : (print "Буги-вуги, йeеe! ")
      sleep 0.3
    end
    print "\r" + " "*rand(1..4)
  end
end

# Не придут...
def stay_home
  loop do
    1.upto(2) do |i|
      print "Я мыслю, следовательно существую... "
      sleep 1.25
    end
    print "\r" + " "*rand(1..4)
  end
end

friends_are_also_coming? ? go_party : stay_home
```
>
С помощью символов `/`, `-`, `\`, `|` сделайте анимацию — индикатор загрузки. Если выводить эти символы по очереди на одном и том же месте, возникает ощущение вращающегося символа.
```ruby
# Индикатор загрузки
loop do
  1.upto(4) do |i|
    print "/\r"; sleep 0.3
    print "-\r"; sleep 0.3
    print "\\\r"; sleep 0.3
    print "|\r"; sleep 0.3
  end
end
```
X> Сделать так, чтобы цикл был теоретически бесконечным. То есть чтобы равновероятно на свет появлялись люди и машины. Количество появившихся людей или машин должно равняться количеству погибших людей или машин. Несмотря на то что теоретически борьба может быть бесконечной, на практике может наступить ситуация, в которой та или иная сторона выигрывает. Проверьте программу на практике, попробуйте разные значения `humans` и `machines` (1000, 100, 10).

```ruby
#"Эмулятор Судного дня, версия 1", line-numbers: false}
########################################
# ОПРЕДЕЛЯЕМ ПЕРЕМЕННЫЕ
########################################

@humans = 8
@machines = 8
@diff = 0

########################################
# ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ
########################################

# Метод возвращает случайное значение: true или false
def luck?
  rand(0..1) == 1
end

def birth
  if luck?
    @machines += @diff
    puts "  #{@diff} машин рождено"
  else
    @humans += @diff
    puts "  #{@diff} людей рождено"
  end
end

def boom
  @diff = rand(1..5)
  if luck?
    @machines -= @diff
    puts "  #{@diff} машин уничтожено"
  else
    @humans -= @diff
    puts "  #{@diff} людей погибло"
  end
end

# Метод возвращает случайное название города
def random_city
  dice = rand(1..5)
  case dice
  when 1; 'Москва'
  when 2; 'Лос-Анджелес'
  when 3; 'Пекин'
  when 4;'Лондон'
  else; 'Сеул'
  end
end

def random_sleep
  sleep rand(0.3..1.5)
end

def stats
  puts "Осталось #{@humans} людей и #{@machines} машин"
end

########################################
# СОБЫТИЯ
########################################

def event1
  puts "Запущена ракета по городу #{random_city}"
  random_sleep
  boom
  random_sleep
  birth
end

def event2
  puts "Применено радиоактивное оружие в городе #{random_city}"
  random_sleep
  boom
  random_sleep
  birth
end

def event3
  puts "Группа солдат прорывает оборону противника в городе #{random_city}"
  random_sleep
  boom
  random_sleep
  birth
end

def event4
  puts "Диверсия на железной дорогое в городе #{random_city}"
  random_sleep
  boom
  random_sleep
  birth
end

def event5
  puts "Землетрясение в городе в городе #{random_city}"
  random_sleep
  boom
  random_sleep
  birth
end


########################################
# ПРОВЕРКА ПОБЕДЫ
########################################

def check_victory?
  @machines <= 0 || @humans <= 0 ? true : false
end

########################################
# ГЛАВНЫЙ ЦИКЛ
########################################

loop do
  if check_victory?
    puts "-"*40
    @humans > 0  ? (puts "Победа! Конец роботам!") : \
                    (puts "The planet is freed from people !")
    puts "-"*40
    exit
  end

  dice = rand(1..5)
  case dice
  when 1; event1
  when 2; event2
  when 3; event3
  when 4; event4
  else event5
  end

  stats
  random_sleep
end
```

###### Однорукий бандит

040.txt:X> Добавьте больше условий в игру «Однорукий бандит», используйте свое воображение.

```ruby
# Программа игровых автоматов

@x; @y; @z

def rand_emoji
  emoji=rand(0..5)
  case emoji
  when 1; "♠"
  when 2; "♥"
  when 4; "♣"
  when 3; "♦"
  else    "☠"
  end
end

print 'Ваш возраст: '
age = gets.to_i
if age < 18
  puts 'Сожалеем, но вам нет 18'
  exit
end

def generator
  # Индикатор загрузки
  1.upto(2) do |i|
    print "Результат: / | /\r"; sleep 0.3
    print "Результат: - \\ -\r"; sleep 0.3
    print "Результат: \\ - \\\r"; sleep 0.3
    print "Результат: | / |\r"; sleep 0.3
  end
  @x = rand_emoji
  @y = rand_emoji
  @z = rand_emoji

  puts "Результат: #{@x} #{@y} #{@z}"
  sleep 0.8
end

balance = 10
loop do
  puts 'Нажмите Enter, чтобы дернуть ручку...'
  gets
  
  generator
  
  if @x == "☠" && @y == "☠" && @z == "☠"
    balance = 0
    puts 'Ваш баланс обнулен'
  elsif @x == "♠" && @y == "♠" && @z == "♠"
    balance += 10
    puts 'Баланс увеличился на 10 долларов'
  elsif @x == "♥" && @y == "♥" && @z == "♥"
    balance += 40
    puts 'Баланс увеличился на 20 долларов'
  elsif @x == "♣" && @y == "♣" && @z == "♣"
    balance += 20
    puts 'Баланс увеличился на 20 долларов'
  elsif @x == "♦" && @y == "♦" && @z == "♦"
    balance += 30
    puts 'Баланс увеличился на 20 долларов'
  else
    balance -= 0.5
    puts 'Баланс уменьшился на 50 центов'
  end

  puts "Ваш баланс: #{balance} долларов"  
end
```

##### Немного про each

>Технически метод each принимает блок... запускает то, что внутри блока для каждого элемента массива... В блок последовательно передается параметр - очередной элемент массива.

Логически блок представляет `операционную возможность` - деятельность `субъекта` над `объектом`, т.е. `для кого` существуют элементарный оъект (элемент массива).

### Битва роботов

##### Философия компьютерной игры
Написать язык программирования и, далее, написать  на нем программу `битва роботов` значит
- изобрести математические абстракции 
	- объект, 
	- правила игры
- согласовать эти абстракции с действительными сущностями
	- субъекты
	- объекты
	- виды деятельности
- пригласить (подключить) действительные сущности к игре
	- дать им средства определить математические абстракции до игровых конкретностей
	- дать им средства для игры

**?** Как выделить абстракции Ruby-языка и средства конкретизировать абстракции эти на примере игры `битва роботов`?
- [ ] составить каталог примитивов, задействованных в наличной программе
- [ ] выразить то, кто и как определяет эти примитивы в конкретности
	- [ ] составить каталог категорий, определяющих примитивы
		- [ ] деятельности
		- [ ] принципы
		- [ ] цели

- [ ] объект игры: `прогресс-бар`
	- [ ] примитив: `стрела`
		- [ ] определитель: `гея`, тяготение, 
			- [ ] как определяет: вертикаль и горизонталь монитора
		- [ ] определитель: `философ`
			- [ ] как определяет: категория, `чистая объективность`
		- [ ] определитель: `боец`, субъект, тот, кто хочет
			- [ ] как определяет: именует отряд роботов, создает миф об этом отряде, его народе
		- [ ] определитель: `отец`, создатель роботов, животное начало
			- [ ] как определяет: 
				- [ ] наделяет их силой-дееспособностью - кормить себя, 
				- [ ] профессионально различает их, специализирует
	- [ ] примитив: `стрела`

##### Игра вообще и игра особенная

- Игра вообще такова постольку, поскольку является единством игр особенных, значит
	- каждый объект игры содержит в себе определеитель каждого субъекта/объекта игры
		- собственно их определяющая роль для того или иного объекта игры, означает их единство, соединненость в игре
- Каждый субъект/объект обязан выражать свою свободу - демонстрировать себя
	- каждый определяет для прочих собственную игру,
		-  прочие соглашаются играть в эту игру
- Игра как единство суть пьеса, единство многих игр в одной игре
- Игра вообще
	- объективности
	- субъективности
	- игры особенные
		- гравитационный субъект
			- давайте двигаться по горизонтали, по правилам механики
		- эволюционный (развивающийся субъект) - давайте будем переходить из одного качества в другое, новое
			- и выражать новое качество, этап вертикальной прокруткой экрана, лентой постов
		- тревожность
			- зрелищность, шум, намеки
		- поединок
			- спортивные правила
		- контроль
			- такие свойства игры, которые необходимы для стыковки со мной, с ее зрителем
		- производство
			- производство солдат, воспроизводство солдат
	- идеи

###### Особенные игры

- Отцовство
	- откармливает детей
		- производитель роботов
	- учит их прокорму
		- противопоставляет одно чадо другому по профессии
			- разделяет труд
	- животное начало
- Тяготение
	- чистая объективность
	- земля, Гея
	- производит вертикаль и горизонаталь
- Математик
	- изобретатель игр
	- объективность игр, их правил
- Субект чистый
	- то, кто хочет, чистое желание
	- тешит напрасную силушку

###### Примитив вообще

- стрелка
	- различенные противоположности
		- начало/конец
		- каждая из противоположностей обязана включать в себя определения всех игроков
	- граница противоположностей
		- соединитель начала и конца

игра "Война роботов" в диком коде, как получится:

```ruby
# Война роботов
#
# Создать два взвода роботов
#
green = Array.new(10,1)
red = Array.new(10,1)

# Определить метод стрельбы
#
def shoot_at( target_arr, \
              l_name, l_health, l_count, \
              r_name, r_health, r_count,
              to_right )
  target = rand(0..9)
  shoot_bar(  l_name, l_health, l_count, \
              r_name, r_health, r_count,\
              to_right )
  if target_arr[ target ] != 0
    target_arr[target] = 0 
    puts "\n  есть попадание на позиции #{target} !"
  else
    puts "\n  промах..."
  end
end
# Определить метод счета действующих роботов
#
def count(arr)
  return arr.count { |element| element != 0 } 
end

def missile
  # тип снарядa
  missile = [ ">", "#","☠","⚕️","✈️","➡️","♂️","♀️","☀","♦","✉","✏","✒"\
              ,"✂","⚒","☢","↗","➡","↘","⬇","↙","⬅","↖","↕","↔","↩"\
              ,"↪","⚛","🕉","✡","☸","☯","✝","☦","☪","☮","▶","◀","✖"\
              ,"◻","▪","▫","☠️" ]
  return missile[ rand(1..missile.length) - 1 ]
end

def shoot_bar(l_name, l_health, l_count, \
              r_name, r_health, r_count, \
              to_right )
  # расчет длины поля левых
  l_health = "100%"                       # здоровье
  l_position = l_name.to_s + " #{l_count.to_s}u " +\
                "#{l_health.to_s}h"
  # ... и правых
  r_health = "100%"                       # здоровье
  r_position = r_name.to_s + " #{r_count.to_s}u " +\
                "#{r_health.to_s}h"
  # расчет дистанции стрельбы
  distance = 80 - ( l_position.size + r_position.size )
  miss_ile = missile                      # тип снаряда

  # полет снаряда
  1.upto(distance) do |i|
    fire = i                              # пламя снаряда
    air = distance - i + 2                # снаряд на два символа

    # атом движения, застывшее мгновение
    case to_right
    when true                             # справа на лево 
      print "#{l_position}" + \
            "="*i + "#{miss_ile}" + ">" + " "*air + \
            "#{r_position}" + "\r"
      sleep rand (0.05..0.09)               # трение переменчиво
    else
      print "#{l_position}" + \
          " "*air + "<" + "#{miss_ile}" + "="*i + \
          "#{r_position}" + "\r"
      sleep rand (0.05..0.09)               # трение переменчиво
    end
  end
end

# Вести войну
#
# Идеальный алгоритм
#
# 0. Определения игры
# 0.1 Размер взвода, одинаков для каждой из сторон
# 0.2 Названия команд, индивидуальные
# 0.3 Здоровье робота: биты или байты? 
#
# 1. жеребьевка первого выстрела
# 2. вызов процедуры 
# 2.1 выстрел
# 2.2 подсчет потерь
# 2.3 вывод о победе
# 2.4 передача хода противнику, п. 2
#
#
loop do
  # Красные слева
  puts " "*28 + "Красные атакуют"
  shoot_at( green, \
              "Красные", 1 , count(red) , \
              "Зеленые", 1 , count(green), \
              true )
  sleep rand(0.5..0.9)
  if  count(green) == 0 
    puts "-"*20 + "\n" + "Конец зеленым!"
    exit
  else 
    # Зеленые справа
    puts " "*28 + "Зелёные атакуют"
    shoot_at( red, \
              "Красные", 1 , count(red), \
              "Зелёные", 1 , count(green), \
              false )
    sleep rand(0.5..0.9)
      if count(red) == 0
        puts "-"*20 + "\n" + "Конец красным!"
        exit
      end
  end
end
```

#### Метапрограммирование

>[Fetching Title#iuda](https://stackoverflow.com/questions/57127038/whats-the-meaning-of)

...в Ruby вы можете указать название метода по его символу, что позволит вам сделать *метапрограммирование*.

Например, обе эти строки делают одно и то же:

```ruby

Time.now
Time.send(:now)
```
Очевидно, что второй длиннее, но он позволяет *указать имя метода на основе переменной*. Вот глупый пример:

```ruby
user.send( age>=18 ? :access : :goback)
```
В зависимости от `age` - выше 18 или нет, будут вызываться разные методы `user`. Теперь, как я уже сказал, это глупый пример, который может быть реализован по-другому. Но имя метода также может быть передано как строка, которая открывает множество возможностей, потому что строки могут быть составными.

В любом случае в вашем случае метод `try` в

```ruby
person_map.try(:[], :name)
```

получает другой метод, именуемый в аргументе. 

Это приводит меня к другой вещи, которая отличается в Ruby от большинства других языков. Да, [] является названием метода. Следует отметить, что для добавления выразительности Ruby позволяет нам создавать имена методов с помощью ? или ! в конце. Конвенция заключается в том, что имена методов заканчиваются `?`, если он возвращает `true` или `false`. Имена методов, заканчивающиеся на `!` меняют исходный объект в отличие от версии без него.

```ruby
new_hash = hash1.merge(hash2) # This returns a completely new object  
hash1.merge!(hash2) # This merges hash2 into hash1
                    # Therefore hash1 is affected
```
А затем, чтобы быть еще более выразительным, вы можете определить несколько методов, которые обычно являются  операторами `\*`, `\==`, `>=`, `<` или другие операторы, как `[]` и снова есть соглашение, но вы можете заставить его вести себя так, как вы пожелаете.

Вы даже можете назвать эти методы обычным способом:

```ruby
age == 13
# is exactly like
age.==(13)

array[3]
# is exactly like
array.[](3)
```
Это, очевидно, выглядит странно, но в основе Ruby лежит удобство, не жертвуя целостностью. По сути, *операторы являются методами* и должны рассматриваться одинаково. Вероятно, они превращаются в вызовы методов в дереве абстрактного синтаксиса.

Возможность переопределять их позволяет рубину делать такие вещи:

```ruby
"h" * 5 # "hhhhh"
"username:password"[/\A[a-z]+/i]
```
Кстати `:[]=` также является именем метода с двумя аргументами:
```ruby
object[key] = "value"

# is exactly like
object.[]=(key, "value")
```
В любом классе вы можете определить эти методы:
```ruby
class Database

  # ...

  def [](id)
    @connection.find_by_id(id)
  end

  def []=(id, data)
    @connection.save(id, data)
  end
end
```
Опять же глупый пример, но он должен показать, что по договоренности эти методы являются `геттерами` и `сеттерами` для какого-то списка вещей, не обязательно `Array` или `Hash`. Это также может быть для определения прокси для базового `Array` или `Hash`. Пока вы можете определить их, мир - это ваша устрица (раковина?), если вы думаете, что он будет более выразительным.

---


### Установка gem-ов

```bash
sudo gem install cowsay
...
Successfully installed cowsay-0.3.0
cowsay 'Привет, Вася!'
 _______________
| Привет, Вася! |
 ---------------
      \   ^__^
       \  (oo)\_______
          (__)\       )\/\
              ||----w |
              ||     ||

sudo gem install pry
pry
[1] pry(main)> green = Array.new(10,1)
=> [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
```
```bash
sudo gem install awesome_print
cat >~/.pryrc
require 'awesome_print'
AwesomePrint.pry!
pry
[1] pry(main)> green = Array.new(10,1)
[
    [0] 1,
    [1] 1,
    [2] 1,
    [3] 1,
    [4] 1,
    [5] 1,
    [6] 1,
    [7] 1,
    [8] 1,
    [9] 1
]
```
#### UML диаграммы в Ruby

Вот такая последовательность действий привела к рисунку с диаграммой:

**1. установить лексический анализатор ascii-документа**

```bash
sudo apt-get install asciidoctor
sudo gem install asciidoctor-diagram
```
**2. Установить образцы документов**

>https://habr.com/ru/companies/sitronics_group/articles/654355/
Документ с диаграммой последовательности на языке `plantUML`:
```asciidoc
[plantuml, format="png", id="vpbx-bwks"]
----
participant Viewer
participant El

Viewer->El: Дай картину
note right of El: Сделать две панели\n и коннектор между ними
El->Viewer: Картина
Viewer->Viewer: Не нравится картина
Viewer->El: Измени картину так-то
note right of El: Корректирую ширирну панелей\n и коннектор между ними
El->Viewer: Картина
Viewer->El: Так хорошо
El->El: Запомнить\nконфиг картины
----
```
Документа записан в файл `diag`

**3. Рисование диаграммы**
>https://github.com/asciidoctor/asciidoctor-diagram/blob/main/examples/README.adoc

```bash
asciidoctor -r asciidoctor-diagram diag
# результат команды:
 diag.html
 diag-plantuml-md5-ecfd07073131addd3a590b326ed401fc.png
```
- `.png` - рисунок с диаграммой
- `.html` - документ с кодом диаграммы и диаграммой

Текстовая диаграмма в форме ascii-риcунка:
```asciidoc
[plantuml, format="txt", id="vpbx-bwks"]
...
```
```text
     ┌──────┐                   ┌──┐
     │Viewer│                   │El│
     └──┬───┘                   └┬─┘
        │       Дай картину      │
        │ ───────────────────────>
        │                        │  ╔═════════════════════════╗
        │                        │  ║Сделать две панели      ░║
        │                        │  ║ и коннектор между ними  ║
        │                        │  ╚═════════════════════════╝
        │         Картина        │
        │ <───────────────────────
        │                        │
        │────┐
        │    │ Не нравится картина
        │<───┘
        │                        │
        │  Измени картину так-то │
        │ ───────────────────────>
        │                        │  ╔═════════════════════════════╗
        │                        │  ║Корректирую ширирну панелей ░║
        │                        │  ║ и коннектор между ними      ║
        │                        │  ╚═════════════════════════════╝
        │         Картина        │
        │ <───────────────────────
        │                        │
        │       Так хорошо       │
        │ ───────────────────────>
        │                        │────┐
        │                        │    │ Запомнить
        │                        │<───┘ конфиг картины
     ┌──┴───┐                   ┌┴─┐
     │Viewer│                   │El│
     └──────┘                   └──┘
``` 


### Состояние объекта

075.txt:X> Напишите класс Monkey («обезьянка»). В классе должно быть: 1) реализовано два метода: `run`, `stop`; 2) каждый из методов должен менять состояние объекта; 3) напишите логику так, чтобы снаружи можно было узнать только о состоянии класса, но нельзя было его модифицировать. Создайте экземпляр класса `Monkey`, вызовите методы объекта и проверьте работоспособность программы.
```ruby
class Monkey
  # определяет метод state возвращающий значение переменной state
  attr_reader :state
  # определяет метод state назначающий значение arg переменной state
  #   закомментированный метод означает невозможность записи в переменную state
  #attr_writer :state

  def initialize
    @state = rand(0..1) == 0 ? :runnig : :stopped
  end
end
```
```pry
 pry -r ./oop.rb
[1] pry(main)> arr = Array.new (10) { Monkey.new }
[2] pry(main)> arr.each { |i| puts "#{i.state}" }
runnig
stopped
runnig
stopped
runnig
runnig
stopped
runnig
runnig
stopped
```

Класс Monkey модифицирован так, чтобы состояние меняли методы, недоступные извне объекта.
```ruby
class Monkey
  # определяет метод state возвращающий значение переменной state
  attr_reader :state
  # определяет метод state назначающий значение arg переменной state
  #   закомментированный метод означает невозможность записи в переменную state
  #attr_writer :state

  def initialize
    @state = rand(0..1) == 0 ? run : stop
  end

  def how_are_you
    # состояние меняется посредством закрытых методов
    @state = rand(0..1) == 0 ? run : stop
    puts "I am #{@state}"
  end

  protected

  def run
    @state = :running
  end

  def stop
    @state = :stopped
  end
end
```
Ключевое слово `protected` закрывает методы `run` и `stop` извне объекта.
```irb
irb(main):001:0> m = Monkey.new
=> #<Monkey:0x000055899d543b30 @state=:running>
irb(main):003:0> m.stop
(irb):3:in `<main>': protected method `stop' called for #<Monkey:0x000055899d543b30 @state=:running> (NoMethodError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<main>'
irb(main):012:0> m.how_are_you
I am stopped
=> nil
irb(main):013:0> m.state
=> :stopped
```

###### Задание
076.txt:X> Пусть метод `initialize` принимает опцию — номер робота. Сделайте так, чтобы номер робота был еще одним параметром, который будет определять его состояние (так же, как и координаты). Измените методы `up` и `down` — если номер робота четный, эти методы не должны производить операции над координатами. Измените методы `left` и `right` — если номер робота нечетный, эти методы также не должны производить никаких операций над координатами. Попробуйте догадаться, что будет на экране при запуске программы.

```ruby
# Класс робота
class Robot
  # Акцессоры — чтобы можно было узнать координаты снаружи
  attr_accessor :x, :y, :id

  # Конструктор, принимает хеш. Если не задан — будет пустой хеш.
  # В хеше мы ожидаем два параметра — начальные координаты робота,
  # если не заданы, будут по умолчанию равны нулю.
  def initialize(options={})
    @x = options[:x] || 0
    @y = options[:y] || 0
    @id = options[:id]
  end

  def right
    # вывов переменной экземпляра (instance variable), которая
    # - именуется `id`
    # - к ней можно обращаться не непосредственно: @id.even?
    #   но через метод .id
    #   соответственно, метод должен быть где-то определен
    #   например, в acessor
    self.id.even? ? self.x += 1 : self.x += 0
  end

  def left
    self.id.even? ? self.x -= 1 : self.x += 0
  end

  def up
    self.id.odd? ? self.y += 1 : self.y += 0
  end

  def down
    self.id.odd? ? self.y -= 1 : self.y += 0
  end
end

# Класс «Командир», который будет командовать и двигать роботов
class Commander
  # Дать команду на движение робота. Метод принимает объект
  # и посылает (send) ему случайную команду.
  def move(who)
    m = [:right, :left, :up, :down].sample
    who.send(m)
  end
end

# Создать объект командира,
# командир в этом варианте программы будет один
commander = Commander.new

# Массив из 10 роботов
arr = Array.new
0.upto(9) { |i| arr[i] = Robot.new({:x=>0,:y=>0,:id=>i}) }

# В бесконечном цикле (для остановки программы нажмите ^C)
loop do
  # Хитрый способ очистить экран
  puts "\e[H\e[2J"

  # Рисуем воображаемую сетку. Сетка начинается от -30 до 30 по X
  # и от 12 до -12 по Y
  (12).downto(-12) do |y|
    (-30).upto(30) do |x|
      # Проверяем, есть ли у нас в массиве робот с координатами x и y
      found = arr.any? { |robot| robot.x == x && robot.y == y }

      # Если найден, рисуем звездочку, иначе точку
      if found
        print '*'
      else
        print '.'
      end
    end

    # Просто переводим строку:
    puts
  end

  # Каждого робота двигаем в случайном направлении
  arr.each do |robot|
    commander.move(robot)
  end

  # Задержка в полсекунды
  sleep 0.5
end
```

```terminal
.............................................................
.............................................................
.............................................................
.............................................................
.............................................................
.............................................................
.............................................................
.............................................................
.............................................................
.............................................................
.............................................................
.............................................................
.............*......*...............*.*......................
.............................................................
.............................................................
..............................*..............................
.............................................................
.............................................................
.............................................................
.............................................................
..............................*..............................
.............................................................
.............................................................
.............................................................
.............................................................
```
Крестообразное расползание роботов от центра x=0, y=0

077.txt:X> Исправьте программу: если все собаки дошли до правого или нижнего края поля, выводить на экран «Win!».
--
093.txt:Исправьте программу: если все собаки дошли до правого или нижнего края поля, выводить на экран «Win!».
093.txt-

```ruby
# Класс робота
class Robot
  # Акцессоры — чтобы можно было узнать координаты снаружи
  attr_accessor :x, :y

  # Конструктор, принимает хеш. Если не задан — будет пустой хеш.
  # В хеше мы ожидаем два параметра — начальные координаты робота,
  # если не заданы, будут по умолчанию равны нулю.
  def initialize(options={})
    @x = options[:x] || 0
    @y = options[:y] || 0
  end

  def right
    self.x += 1
  end

  def left
    self.x -= 1
  end

  def up
    self.y += 1
  end

  def down
    self.y -= 1
  end
  
  def label
    "*"
  end

end

# Класс Собаки 
class Dog
  # Акцессоры — чтобы можно было узнать координаты снаружи
  attr_accessor :x, :y

  # Конструктор, принимает хеш. Если не задан — будет пустой хеш.
  # В хеше мы ожидаем два параметра — начальные координаты робота,
  # если не заданы, будут по умолчанию равны нулю.
  def initialize(options={})
    @x = options[:x] || 0
    @y = options[:y] || 0
  end

  def right
    self.x += 1
  end

  def left
  end

  def up
  end

  def down
    self.y -= 1
  end

  def label
    "@"
  end
end
# Класс «Командир», который будет командовать и двигать роботов
class Commander
  # Дать команду на движение робота. Метод принимает объект
  # и посылает (send) ему случайную команду.
  def move(who)
    m = [:right, :left, :up, :down].sample
    who.send(m)
  end
end

# Создать объект командира,
# командир в этом варианте программы будет один
commander = Commander.new

# Массив из 10 роботов
arr = Array.new(10) { Robot.new }
1.upto(4) { |i| arr.push(Dog.new(x: -12, y: 12)) }

# В бесконечном цикле (для остановки программы нажмите ^C)
loop do
  # Хитрый способ очистить экран
  puts "\e[H\e[2J"

  # Рисуем воображаемую сетку. Сетка начинается от -12 до 12 по X
  # и от 12 до -12 по Y
  (12).downto(-12) do |y|
    (-12).upto(12) do |x|
      # Проверяем, есть ли у нас в массиве робот с координатами x и y
      found = arr.find { |somebody| somebody.x == x && somebody.y == y }

      # Если найден, рисуем звездочку, иначе точку
      if found
        print found.label
      else
        print '.'
      end
    end

    # Просто переводим строку:
    puts
  end

  # Проверка столкновения. Если есть два объекта с одинаковыми
  # координатами и их «label» не равны, то, значит, робот поймал собаку.
  game_over = arr.combination(2).any? do |a, b|
    a.x == b.x && \
    a.y == b.y && \
    a.label != b.label
  end

  if game_over
    puts 'Game over'
    exit
  end

  # Проверка удачного прохода всех собак
  # Если все четыре собаки пересекли финишныe линии
  game_win = arr.combination(4).any? do |a, b, c, d|
    (a.x >= 12 || a.y <= -12) && a.label == "@" && \
    (b.x >= 12 || b.y <= -12) && b.label == "@" && \
    (c.x >= 12 || c.y <= -12) && c.label == "@" && \
    (d.x >= 12 || d.y <= -12) && d.label == "@" 
  end
  if game_win
    puts "Win!"
    exit
  end 

  # Каждый объект двигается в случайном направлении
  arr.each do |somebody|
    commander.move(somebody)
  end

  # Задержка в полсекунды
  sleep 0.5
end
```


#### Subtyping (субтипирование) против наследования

080.txt:X> Не подсматривая в код, который написан чуть ниже, попробуйте написать программу по диаграмме классов на представленном рисунке.

```ruby
# Роботы, собаки и человек
#
# классы конкретные и классы абстрактные связаны наследованием
# наследованием не смысловым, сущностным, а материальным -
# абстрактный класс предоставляет унифицированные шестиренки и
# болты лего для произвольных композиций
#
# Класс Player
#
class Player
  # Акцессоры — чтобы можно было узнать координаты снаружи
  attr_accessor :x, :y

  # Конструктор, принимает хеш. Если не задан — будет пустой хеш.
  # В хеше мы ожидаем два параметра — начальные координаты робота,
  # если не заданы, будут по умолчанию равны нулю.
  def initialize(options={})
    @x = options[:x] || 0
    @y = options[:y] || 0
  end

  def right
    self.x += 1
  end

  def left
    self.x -= 1
  end

  def up
    self.y += 1
  end

  def down
    self.y -= 1
  end
  
  def label
    "#"
  end

end
# Класс робота
class Robot < Player

  def label
    "*"
  end

end

# Класс Собаки 
class Dog < Player

  def left
  end

  def up
  end

  def label
    "@"
  end
end

# Класс «Командир», который будет командовать и двигать роботов
class Commander
  # Дать команду на движение робота. Метод принимает объект
  # и посылает (send) ему случайную команду.
  def move(who)
    m = [:right, :left, :up, :down].sample
    who.send(m)
  end
end

# Создать объект командира,
# командир в этом варианте программы будет один
commander = Commander.new

# Массив из 10 роботов
arr = Array.new(10) { Robot.new }
1.upto(4) { |i| arr.push(Dog.new(x: -12, y: 12)) }

# В бесконечном цикле (для остановки программы нажмите ^C)
loop do
  # Хитрый способ очистить экран
  puts "\e[H\e[2J"

  # Рисуем воображаемую сетку. Сетка начинается от -12 до 12 по X
  # и от 12 до -12 по Y
  (12).downto(-12) do |y|
    (-12).upto(12) do |x|
      # Проверяем, есть ли у нас в массиве робот с координатами x и y
      found = arr.find { |somebody| somebody.x == x && somebody.y == y }

      # Если найден, рисуем звездочку, иначе точку
      if found
        print found.label
      else
        print '.'
      end
    end

    # Просто переводим строку:
    puts
  end

  # Проверка столкновения. Если есть два объекта с одинаковыми
  # координатами и их «label» не равны, то, значит, робот поймал собаку.
  game_over = arr.combination(2).any? do |a, b|
    a.x == b.x && \
    a.y == b.y && \
    a.label != b.label
  end

  if game_over
    puts 'Game over'
    exit
  end

  # Проверка удачного прохода всех собак
  # Если все четыре собаки пересекли финишныe линии
  game_win = arr.combination(4).any? do |a, b, c, d|
    (a.x >= 12 || a.y <= -12) && a.label == "@" && \
    (b.x >= 12 || b.y <= -12) && b.label == "@" && \
    (c.x >= 12 || c.y <= -12) && c.label == "@" && \
    (d.x >= 12 || d.y <= -12) && d.label == "@" 
  end
  if game_win
    puts "Win!"
    exit
  end 

  # Каждый объект двигается в случайном направлении
  arr.each do |somebody|
    commander.move(somebody)
  end

  # Задержка в полсекунды
  sleep 0.5
end
```


## Практическое занятие: подбор пароля и спасение мира

087.txt:Команда выше состоит из двух команд:
087.txt-
087.txt-* `docker rm xxx` — удаляет контейнер с именем «xxx» (если он существует. Если нет, то появится ошибка «Error: No such container: xxx» — это нормально, просто проигнорируйте ее);
087.txt-* `docker run -it --name xxx -p 4567:4567 ro31337/rubybook-save-the-world` (запускает контейнер и «пробрасывает» порт 4567 на локальный хост).
