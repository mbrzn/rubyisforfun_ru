# Часть 1. Первые шаги
[[bat_install.sh|установить bat]]

Защитить файл журнала от перезаписи:
```bash
 1305  sudo chattr +a p1.md 
 1320  history | grep chattr >> p1.md
```
Поиск файлов
найти руби файлы на компьютере, полюбоваться их синтаксической формой
```bash
 1329  sudo find / -name '*.rb' | tail -10 | xargs bat 
 1332  history | grip 'xargs bat' >>p1.md
 1333  history | grep 'xargs bat' >>p1.md
```
>[!Note]
holy wars - святые войны

Интерактивная программа:
- выводит строку
- ждет ввода строки
- выводит строку
- ждет ввода
- и т.д.

```ruby
puts "How to translate ball?"
gets
puts "How to translate cap?"
gets
puts "How to translate cat?"
gets
puts "How to translate bat?"
gets
puts "How to translate ruby?"
gets
```

## Часть 2. Основы

### Все есть класс

```ruby
puts 12.class
puts Integer.class
puts Class.class
```
```terminal
Integer
Class
Class
```
>Говорят, что все в Руби — объект (Object). В результате любой операции получается объект. Каждый объект «*реализует метод*» `class`. Выражение «*реализует метод*» означает, что какой-то программист, разработчик языка Руби, сделал специальную небольшую подпрограмму, которую мы с вами можем запускать, если знаем имя этой подпрограммы. Чтобы вызвать подпрограмму для какого-либо объекта, нужно ввести точку и написать имя этой подпрограммы.
>Экземпляр класса Object - число 1 - являетя объектом, но не является классом


- экземпляр класса Class - объект Object - является классом
- объект класса Class - объект Class - является классом, т.е. подкласс 

```ruby
irb(main):012:0> 1.is_a?(Object)
=> true
irb(main):013:0> 1.is_a?(Class)
=> false
irb(main):014:0> Object.is_a?(Class)
=> true
irb(main):015:0> Class.is_a?(Class)
=> true
irb(main):016:0>
```
```ruby
irb(main):001:0> Class.is_a?(Object)
=> true
```

>[!Question] Как относятся понятия
Объект и Класс?

String нельзя складывать с Integer, полагается - операция применима только к объектам одного класса. Чтобы применить операцию печати объекта класса String к чужеродному объекту (класса Integer), его нужно преобразовать, привести к классу String.  Т.е. изготовить небывалый ранее объект - строку высосанную из пальца, в процессе размышлений о числе. Эта высосанная из пальца ассоциация cугубо субъективна - так захотел программист.
```ruby
# приведение строки к числу, а числа к строке
irb(main):001:0> age=gets
33
=> "33\n"
irb(main):002:0> puts "Age is " + ( age.to_i * 12 ).to_s + " monthes."
Age is 396 monthes.
=> nil
```
>[!Note] Здравствуйте, я ваш REPL
>Из начальных букв у нас получилось REPL — read evaluate print loop. То есть REPL — это такая программа, которая сначала читает, потом исполняет, потом печатает результат и затем начинает все сначала. Это понятие широко известно и используется не только в Руби. А в Руби REPL-программа называется irb (interactive ruby).

### Размер объекта

Объекту языка свойствена мера. Так объект типа String измеряется в символах:
```ruby
irb(main):014:0> "hello".size
=> 5
```

Объекту тип Integer свойственно имеряться в 8-и байтовых словах:
```ruby
# это число не вмещается в 64 бита:
irb(main):012:0> (2**64).size
=> 9
# ему нужно 9-ть слов
#
# а вот этому числу достаточно 8-и слов
irb(main):013:0> (2**63).size
=> 8
irb(main):009:0> 3.size
=> 8
# ... как и числу 3
```

### Интерполяция строк

Строки в двойных кавычках интерпретируются как символы печатной машинки - обычные и специальные (типа перевода каретки):
```ruby
irb(main):001:0> "Hello\n".chomp.size
=> 5
irb(main):002:0> "Hello".chomp.size
=> 5
```
Строки в одинарных кавычках для ruby - *не аналоговые*, не из печатной машинки, а *цифровые* - здесь нет понятия `специального символа`, здесь символы - это `байт`-ы:
```ruby
irb(main):003:0> 'Hello\n'.chomp.size
=> 7
```
##### Задание 2

> Напишите программу для подсчета годовой зарплаты. Пользователь вводит размер заработной платы в месяц, а программа выводит размер заработной платы в год. Допустим, что пользователь каждый месяц хочет откладывать 15 % своей зарплаты. Измените программу, чтобы она выводила не только размер заработной платы, но и размер отложенных за год средств. Измените программу, чтобы она выводила размер отложенных средств за 5 лет.
```ruby
puts "Input your month income:"
inc_m=gets.to_f
puts "If put 15% isurance, then:"
inc_y=inc_m*12
insr_y=inc_y*15/100
puts "\tyear income is #{inc_y}"
puts "\tyears insurance #{insr_y}"
puts "\t5 year income is #{inc_y*5}"
puts "\t5 years insurance is #{insr_y*5}"
```
```terminal
Input your month income:
45000
If put 15% isurance, then:
        year income is 540000.0
        years insurance 81000.0
        5 year income is 2700000.0
        5 years insurance is 405000.0
```

#### Bang!

Язык - суть именование адресов на объекты памяти:
- Оъект - это физические выключатели в микросхеме памяти, составляющие единство. Это единство и есть объект языка.
- Имя, переменная - это слово в словаре - хэш-таблице из человеческих слов (имен переменных) и адресов объектов в памяти машины.
- Адрес - это логический элемент, атом древовидной логической конструкции:
    - физические элементы машины изготовлены по древовидному чертежу
    - умозрение программиста оперирует абстракциями по древовидному чертежу
    - производитель машин и программист руководствуются конвенцией, соглашением - давайте будем использовать общую логико-математическую теорию (целостную систему рассуждений) для нашей общей коммерческой выгоды

Оператор `Bang!` проявляет объективность объекта (физическое тело, единица) и субъективность программиста:
- программист может называть объект так, как ему `удобно`
- объект же остается единицей (но не множеством)
    - объект один, а имен - множество

> [!Attention] Коробочка со значением и ссылка. 
> Две коробочки и их отношение.
> [[Максим @demimurych|Гений эффективности]] о переменных: [Почему ООП умирает | Стрим про языки программирования с @AsForJS - YouTube](https://youtu.be/mxquElJC_qM?t=857)

```ruby
irb(main):001:0> obj_name_1="СоСТОЯние ЕдИНСТВа ВЫКлючателей В МИКросХЕМе ПАмяти"
=> "СоСТОЯние ЕдИНСТВа ВЫКлючателей В МИКросХЕМе ПАмяти"
irb(main):002:0> obj_name_2=obj_name_1
=> "СоСТОЯние ЕдИНСТВа ВЫКлючателей В МИКросХЕМе ПАмяти"
irb(main):003:0> # Все то же единство физических выключателей можем именовать
=> nil
irb(main):004:0> # по-другому, вторым именем
=> nil
irb(main):005:0> # Спросим абстракцию: Что у тебя за душой?
=> nil
irb(main):006:0> puts obj_name_1
СоСТОЯние ЕдИНСТВа ВЫКлючателей В МИКросХЕМе ПАмяти
=> nil
irb(main):007:0> # Изменение абстракции равно изменению физического атома? Абстрация физически полезна?
=> nil
irb(main):008:0> puts obj_name_1.downcase!
состояние единства выключателей в микросхеме памяти
=> nil
irb(main):009:0> # Полезна - изменение физического атома налицо.
=> nil
irb(main):010:0> # Вопрос вопросов о мышлении: А вот за вторым именем объекта что-то независимое от оъекта есть?
=> nil
irb(main):011:0> puts obj_name_2
состояние единства выключателей в микросхеме памяти
=> nil
irb(main):012:0> # Нет, за вторым именем нет ничего физически иного в физически атомном.
=> nil
```

>[!Question] Основной вопрос философии
>Как второе имя вещи влияет на вещь?
>
>Не замысел ли программиста приговаривает вещь. Программист - судьба вещи?
#### Оператор присваивания суть объективность

Объективность программирования является в операторе "=", *отношение созидания*
- оператор "=" полагает отношение
    - физического объекта
    - духовной деятельности - сфера имен и мечт
    - бракосочетание души программиста и физического голема из глины

Писатель знака "=" творит миф для голема. Имена - имена ролей, которые будет играть голем в пьесе писателя-программиста.

>* Оператор присваивания **=** автоматически создаёт новый объект для переменной;
>* одинаковых значений может быть множество;
>* наименование каждой переменной уникально.

>[!Note] Сфера программирования
> Кажется, детонат, смысл, знак и символ - это и есть те
> понятия, которыми определяется деятельность пространства имен, пространство возможных пьес, сфера Витгенштейна.
> - [[lit/87.442 Модуль 1. Предмет логики]]
>- [[lit/87.442 Модуль 2. Логика терминов]]
>- [[Некоторые спорные размышления над работой Г. Фреге «Смысл и денотат»  Хабр]]

>[class String - Documentation for Ruby 3.4](https://docs.ruby-lang.org/en/master/String.html#method-i-chomp)
>Some String methods modify self. Typically, a method whose name ends with ! modifies self and returns self; often a similarly named method (without the !) returns a new string.
>`String#sub!`: One substitution (or none); returns self.
>`String#gsub!`: Zero or more substitutions; returns self.
>>s = 'hello'
>>s.gsub(/[aeiou]/, '*') # => "h*ll*"
>>chomp!

#### Загадка о замороженном литерале

Наличие комментария в программе, влияет на ее результат. Почему?
```ruby
# frozen_string_literal: true
a='aaa'
b='aaa'
puts a.object_id
puts b.object_id
```
```terminal
# если комментарий есть, то вывод:
60
60
# если комментария нет, то вывод:
60
80
# если комментарий есть, но в нем вместо true указано false, то вывод:
60
80
```
- [x] Значит, ruby понимает некторые коментарии как директивы
- [x] директива` frozen_`... устанавливает единственность или множественность объектов физических (в памяти, в микросхеме), создаваемых интерпретатором при чтении текста программы. Что имел в виду программист, указывая в программе строку 'aaa' дважды?
	- один физический объект?
	- два?
	- [x] Директива `frozen_`... указывает на тип умостроя автора программы программе.

### Блок

Оператор применяется к блоку в фигурных скобках. Всякий (!) метод применим к блоку.
>[!Question] Блок - объект?
Почему блок универсален?

```ruby
loop { print 'Рома ' }
```

- [x] Блок - не объект, а некое прилагаемое лишь. Блок сам по себе существовать не может.

Объект Integer передает в блок параметр - число i:
```ruby
sum=0
12.times do |i|
  sum=sum+i
  puts "sum = #{sum} i = #{i}"
end
```
Т.о. блок вообще - это некое прилагаемое к методу объекта, нечто методное.
###### Задание 2
>Измените программу из предыдущего задания со следующими условиями: человек берет дом не в рассрочку, а в кредит по ставке 4 % годовых на оставшуюся сумму. Для каждого года посчитайте, сколько денег нужно заплатить за этот год за использование кредита.
>Измените программу из предыдущего задания со следующими условиями: человек берет дом не в рассрочку, а в кредит по ставке 4 % годовых на оставшуюся сумму. Для каждого года посчитайте, сколько денег нужно заплатить за этот год за использование кредита.
```ruby
cost=500000
irb(main):026:1* period.times do |i|
irb(main):027:1*   puts "конец #{i+1}-го года: %% #{cost*( 1 - i.to_f/period.to_f )*0.04}"
irb(main):028:0> end
```
###### Задание 3

>Посчитайте количество денег (total), которые мы заплатим только в виде процентов по кредиту за 30 лет.
```ruby
irb(main):006:0> cost=500000
=> 500000
irb(main):007:0> sum_proc=0
=> 0
irb(main):008:0> period=30
=> 30
irb(main):009:1* period.times do |i|
irb(main):010:1*   sum_proc=sum_proc + cost*( 1 - i.to_f/period.to_f )*0.04
irb(main):011:1*   puts "конец #{i+1}-го года: %% #{sum_proc}"
irb(main):012:0> end
```

#### TrueClass и FalseClass

Знак вопроса в конце метода говорит лишь о том, что метод возвращает значение типа *Boolean* (в языке Руби нет отдельного типа для *Boolean*, поэтому это либо *TrueClass* тип, либо *FalseClass* тип). Другими словами, значение либо *true*, либо *false*. Например, метод, который определяет, беременна ли девушка, можно записать только со знаком вопроса в конце, потому что результат — или *true* (истина), или *false* (ложь). Часто такие методы начинаются со слова `is`:

```ruby
irb(main):002:0> (1.even?).class
=> FalseClass
irb(main):003:0> (1.odd?).class
=> TrueClass
irb(main):004:0>
```

Метод `even?` объекта `1` возвращает объект класса `FalseClass` - что означает *не принадлежать классу четных чисел*.
Результатом логического выражения является объект одного из двух классов, которые привычно ассоциируются с истиной и ложью:

```ruby
irb(main):001:0> 10%2==0
=> true
irb(main):002:0> 10%2!=0
=> false
irb(main):003:0> (10%2!=0).class
=> FalseClass
```

> Вывести на экран числа от 50 до 100.
> Вывести на экран числа от 50 до 100, и если число четное — рядом с ним написать `true`, если нечетное — `false`.

```ruby
irb(main):005:0> 50.upto(100) { |i| puts "#{i}" }
irb(main):004:0> 51.times { |i| puts "#{i+50}" }
```
Первое решение - буквальное выражение человеческого языка.

```ruby
irb(main):004:1* 50.upto(100) do|i|
irb(main):005:1*   puts "#{i} : " + "#{i.even?}"
irb(main):006:0> end
```

> Вы создаете веб-сайт для барбер-шопа. Выведите на экран все виды текстурного крема для волос. Каждый вид крема имеет два параметра, SHINE (блеск) и HOLD (стойкость). Каждый параметр представлен цифрой от 1 до 5.

```ruby
irb(main):012:1* 1.upto(up_shine) do |i|
irb(main):013:2*   1.upto(up_hold) do |j|
irb(main):014:2*     puts "SHINE #{i} / HOLD #{j}"
irb(main):015:1*   end
irb(main):016:0> end
```

## Ветвление

> Известно, что на Луне продают участки. Любой участок менее 50 квадратных метров стоит 1000 долларов. Участок площадью от 50 до 100 квадратных метров стоит 1500 долларов. От 100 и выше — по 25 долларов за квадратный метр. Напишите программу, которая запрашивает длину и ширину участка и выводит на экран его стоимость.
> Известно, что на Луне продают участки. Любой участок менее 50 квадратных метров стоит 1000 долларов. Участок площадью от 50 до 100 квадратных метров стоит 1500 долларов. От 100 и выше — по 25 долларов за квадратный метр. Напишите программу, которая запрашивает длину и ширину участка и выводит на экран его стоимость.
```ruby
puts "Цена луны #{1000} if s<50"
puts "Цена луны #{1500} if s>50 && s<100"
puts "Цена луны #{25}*s if s>=100"

puts "Input width:"
w=gets.chomp.to_f
puts "Input length:"
l=gets.chomp.to_f
s=w*l
puts "Цена луны #{1000}" if s<50
puts "Цена луны #{1500}" if s>50 && s<100
puts "Цена луны #{25*s}" if s>=100
```

> Напишите программу «иммигрант». Программа должна задавать следующие вопросы: «У вас есть высшее образование? (y/n)», «У вас есть опыт работы программистом? (y/n)», «У вас более трех лет опыта? (y/n)». За каждый положительный ответ начисляется 1 балл (переменную можно назвать score). Если набралось 2 или более баллов, программа должна выводить на экран «Добро пожаловать в США».

```ruby
score=0
puts "У вас есть высшее образование? (y/n)"
score=1 if gets.chomp.downcase == 'y'
puts "У вас есть опыт работы программистом? (y/n)"
score=score+1 if gets.chomp.downcase == 'y'
puts "У вас более трех лет опыта? (y/n)"
score=score+1 if gets.chomp.downcase == 'y'
puts "Добро пожаловать в США." if score >= 3
```

> Измените программу, чтобы она загадывала число от 1 до 1_000_000 (1 миллиона). Чтобы можно было угадать это число, программа должна сравнивать текущий ответ пользователя и искомое число: 1) если ответ пользователя больше, то программа должна выводить на экран «Искомое число меньше вашего ответа»; 2) иначе «Искомое число больше вашего ответа». Может показаться, что угадать это число невозможно, однако математический расчет показывает, что угадать число в этом случае можно не более, чем за 20 попыток.
> Напишите программу, чтобы она загадывала число от 1 до 1_000_000 (1 миллиона). Чтобы можно было угадать это число, программа должна сравнивать текущий ответ пользователя и искомое число: 1) если ответ пользователя больше, то программа должна выводить на экран «Искомое число меньше вашего ответа»; 2) иначе «Искомое число больше вашего ответа». Может показаться, что угадать это число невозможно, однако математический расчет показывает, что угадать число в этом случае можно не более, чем за 20 попыток.

```ruby
number=rand(1..1000000)
print 'Привет! Я загадал число от до 1000000, попробуйте угадать:'

loop do
  input=gets.to_i

  if input == number
    puts 'Правильно!'
    exit
  else
    if input > number
      print'Неправильно, искомое число меньше, попробуйте еще раз:'
    else
      print'Неправильно, искомое число больше, попробуйте еще раз:'
    end
  end
end
```
## Часть 3. Время веселья

### Тернарный оператор


###### Задание
>
> Запишите следующие примеры при помощи тернарного оператора.
```ruby
# Придут или не придут?
def friends_are_also_coming?
  1.upto(5) do |i|
    sleep 0.743
    rand(1..2) == 1 ? (print "Придут? ... ") : (print "Не придут...  ")
  end
  print "\r"
  return rand(1..2)==1 ? (2*2==4) : (2*2==5)
end

# Придут !
def go_party
  loop do
    1.upto(4) do |i|
      rand(1..2) == 1 ? (print "Ураааааааа ! ") : (print "Буги-вуги, йeеe! ")
      sleep 0.3
    end
    print "\r" + " "*rand(1..4)
  end
end

# Не придут...
def stay_home
  loop do
    1.upto(2) do |i|
      print "Я мыслю, следовательно существую... "
      sleep 1.25
    end
    print "\r" + " "*rand(1..4)
  end
end

friends_are_also_coming? ? go_party : stay_home
```
>
С помощью символов `/`, `-`, `\`, `|` сделайте анимацию — индикатор загрузки. Если выводить эти символы по очереди на одном и том же месте, возникает ощущение вращающегося символа.
```ruby
# Индикатор загрузки
loop do
  1.upto(4) do |i|
    print "/\r"; sleep 0.3
    print "-\r"; sleep 0.3
    print "\\\r"; sleep 0.3
    print "|\r"; sleep 0.3
  end
end
```
X> Сделать так, чтобы цикл был теоретически бесконечным. То есть чтобы равновероятно на свет появлялись люди и машины. Количество появившихся людей или машин должно равняться количеству погибших людей или машин. Несмотря на то что теоретически борьба может быть бесконечной, на практике может наступить ситуация, в которой та или иная сторона выигрывает. Проверьте программу на практике, попробуйте разные значения `humans` и `machines` (1000, 100, 10).

```ruby
#"Эмулятор Судного дня, версия 1", line-numbers: false}
########################################
# ОПРЕДЕЛЯЕМ ПЕРЕМЕННЫЕ
########################################

@humans = 8
@machines = 8
@diff = 0

########################################
# ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ
########################################

# Метод возвращает случайное значение: true или false
def luck?
  rand(0..1) == 1
end

def birth
  if luck?
    @machines += @diff
    puts "  #{@diff} машин рождено"
  else
    @humans += @diff
    puts "  #{@diff} людей рождено"
  end
end

def boom
  @diff = rand(1..5)
  if luck?
    @machines -= @diff
    puts "  #{@diff} машин уничтожено"
  else
    @humans -= @diff
    puts "  #{@diff} людей погибло"
  end
end

# Метод возвращает случайное название города
def random_city
  dice = rand(1..5)
  case dice
  when 1; 'Москва'
  when 2; 'Лос-Анджелес'
  when 3; 'Пекин'
  when 4;'Лондон'
  else; 'Сеул'
  end
end

def random_sleep
  sleep rand(0.3..1.5)
end

def stats
  puts "Осталось #{@humans} людей и #{@machines} машин"
end

########################################
# СОБЫТИЯ
########################################

def event1
  puts "Запущена ракета по городу #{random_city}"
  random_sleep
  boom
  random_sleep
  birth
end

def event2
  puts "Применено радиоактивное оружие в городе #{random_city}"
  random_sleep
  boom
  random_sleep
  birth
end

def event3
  puts "Группа солдат прорывает оборону противника в городе #{random_city}"
  random_sleep
  boom
  random_sleep
  birth
end

def event4
  puts "Диверсия на железной дорогое в городе #{random_city}"
  random_sleep
  boom
  random_sleep
  birth
end

def event5
  puts "Землетрясение в городе в городе #{random_city}"
  random_sleep
  boom
  random_sleep
  birth
end


########################################
# ПРОВЕРКА ПОБЕДЫ
########################################

def check_victory?
  @machines <= 0 || @humans <= 0 ? true : false
end

########################################
# ГЛАВНЫЙ ЦИКЛ
########################################

loop do
  if check_victory?
    puts "-"*40
    @humans > 0  ? (puts "Победа! Конец роботам!") : \
                    (puts "The planet is freed from people !")
    puts "-"*40
    exit
  end

  dice = rand(1..5)
  case dice
  when 1; event1
  when 2; event2
  when 3; event3
  when 4; event4
  else event5
  end

  stats
  random_sleep
end
```

###### Однорукий бандит

040.txt:X> Добавьте больше условий в игру «Однорукий бандит», используйте свое воображение.

```ruby
# Программа игровых автоматов

@x; @y; @z

def rand_emoji
  emoji=rand(0..5)
  case emoji
  when 1; "♠"
  when 2; "♥"
  when 4; "♣"
  when 3; "♦"
  else    "☠"
  end
end

print 'Ваш возраст: '
age = gets.to_i
if age < 18
  puts 'Сожалеем, но вам нет 18'
  exit
end

def generator
  # Индикатор загрузки
  1.upto(2) do |i|
    print "Результат: / | /\r"; sleep 0.3
    print "Результат: - \\ -\r"; sleep 0.3
    print "Результат: \\ - \\\r"; sleep 0.3
    print "Результат: | / |\r"; sleep 0.3
  end
  @x = rand_emoji
  @y = rand_emoji
  @z = rand_emoji

  puts "Результат: #{@x} #{@y} #{@z}"
  sleep 0.8
end

balance = 10
loop do
  puts 'Нажмите Enter, чтобы дернуть ручку...'
  gets
  
  generator
  
  if @x == "☠" && @y == "☠" && @z == "☠"
    balance = 0
    puts 'Ваш баланс обнулен'
  elsif @x == "♠" && @y == "♠" && @z == "♠"
    balance += 10
    puts 'Баланс увеличился на 10 долларов'
  elsif @x == "♥" && @y == "♥" && @z == "♥"
    balance += 40
    puts 'Баланс увеличился на 20 долларов'
  elsif @x == "♣" && @y == "♣" && @z == "♣"
    balance += 20
    puts 'Баланс увеличился на 20 долларов'
  elsif @x == "♦" && @y == "♦" && @z == "♦"
    balance += 30
    puts 'Баланс увеличился на 20 долларов'
  else
    balance -= 0.5
    puts 'Баланс уменьшился на 50 центов'
  end

  puts "Ваш баланс: #{balance} долларов"  
end
```

##### Немного про each

>Технически метод each принимает блок... запускает то, что внутри блока для каждого элемента массива... В блок последовательно передается параметр - очередной элемент массива.

Логически блок представляет `операционную возможность` - деятельность `субъекта` над `объектом`, т.е. `для кого` существуют элементарный оъект (элемент массива).
### Битва роботов
##### Философия компьютерной игры
Написать язык программирования и, далее, написать  на нем программу `битва роботов` значит
- изобрести математические абстракции 
	- объект, 
	- правила игры
- согласовать эти абстракции с действительными сущностями
	- субъекты
	- объекты
	- виды деятельности
- пригласить (подключить) действительные сущности к игре
	- дать им средства определить математические абстракции до игровых конкретностей
	- дать им средства для игры

**?** Как выделить абстракции Ruby-языка и средства конкретизировать абстракции эти на примере игры `битва роботов`?
- [ ] составить каталог примитивов, задействованных в наличной программе
- [ ] выразить то, кто и как определяет эти примитивы в конкретности
	- [ ] составить каталог категорий, определяющих примитивы
		- [ ] деятельности
		- [ ] принципы
		- [ ] цели

- [ ] объект игры: `прогресс-бар`
	- [ ] примитив: `стрела`
		- [ ] определитель: `гея`, тяготение, 
			- [ ] как определяет: вертикаль и горизонталь монитора
		- [ ] определитель: `философ`
			- [ ] как определяет: категория, `чистая объективность`
		- [ ] определитель: `боец`, субъект, тот, кто хочет
			- [ ] как определяет: именует отряд роботов, создает миф об этом отряде, его народе
		- [ ] определитель: `отец`, создатель роботов, животное начало
			- [ ] как определяет: 
				- [ ] наделяет их силой-дееспособностью - кормить себя, 
				- [ ] профессионально различает их, специализирует
	- [ ] примитив: `стрела`

##### Игра вообще и игра особенная
- Игра вообще такова постольку, поскольку является единством игр особенных, значит
	- каждый объект игры содержит в себе определеитель каждого субъекта/объекта игры
		- собственно их определяющая роль для того или иного объекта игры, означает их единство, соединненость в игре
- Каждый субъект/объект обязан выражать свою свободу - демонстрировать себя
	- каждый определяет для прочих собственную игру,
		-  прочие соглашаются играть в эту игру
- Игра как единство суть пьеса, единство многих игр в одной игре
- Игра вообще
	- объективности
	- субъективности
	- игры особенные
		- гравитационный субъект
			- давайте двигаться по горизонтали, по правилам механики
		- эволюционный (развивающийся субъект) - давайте будем переходить из одного качества в другое, новое
			- и выражать новое качество, этап вертикальной прокруткой экрана, лентой постов
		- тревожность
			- зрелищность, шум, намеки
		- поединок
			- спортивные правила
		- контроль
			- такие свойства игры, которые необходимы для стыковки со мной, с ее зрителем
		- производство
			- производство солдат, воспроизводство солдат
	- идеи

###### Особенные игры
- Отцовство
	- откармливает детей
		- производитель роботов
	- учит их прокорму
		- противопоставляет одно чадо другому по профессии
			- разделяет труд
	- животное начало
- Тяготение
	- чистая объективность
	- земля, Гея
	- производит вертикаль и горизонаталь
- Математик
	- изобретатель игр
	- объективность игр, их правил
- Субект чистый
	- то, кто хочет, чистое желание
	- тешит напрасную силушку
###### Примитив вообще
- стрелка
	- различенные противоположности
		- начало/конец
		- каждая из противоположностей обязана включать в себя определения всех игроков
	- граница противоположностей
		- соединитель начала и конца