# Часть 1. Первые шаги
[[bat_install.sh|установить bat]]

Защитить файл журнала от перезаписи:
```bash
 1305  sudo chattr +a p1.md 
 1320  history | grep chattr >> p1.md
```
Поиск файлов
найти руби файлы на компьютере, полюбоваться их синтаксической формой
```bash
 1329  sudo find / -name '*.rb' | tail -10 | xargs bat 
 1332  history | grip 'xargs bat' >>p1.md
 1333  history | grep 'xargs bat' >>p1.md
```
>[!Note]
holy wars - святые войны


Интерактивная программа:
- выводит строку
- ждет ввода строки
- выводит строку
- ждет ввода
- и т.д.
```ruby
puts "How to translate ball?"
gets
puts "How to translate cap?"
gets
puts "How to translate cat?"
gets
puts "How to translate bat?"
gets
puts "How to translate ruby?"
gets
```

## Часть 2. Основы

### Все есть класс

```ruby
puts 12.class
puts Integer.class
puts Class.class
```
```terminal
Integer
Class
Class
```
>
Говорят, что все в Руби — объект (Object). В результате любой операции получается объект. Каждый объект «*реализует метод*» `class`. Выражение «*реализует метод*» означает, что какой-то программист, разработчик языка Руби, сделал специальную небольшую подпрограмму, которую мы с вами можем запускать, если знаем имя этой подпрограммы. Чтобы вызвать подпрограмму для какого-либо объекта, нужно ввести точку и написать имя этой подпрограммы.
Экземпляр класса Object - число 1 - являетя объектом, но не является классом
- экземпляр класса Class - объект Object - является классом
- объект класса Class - объект Class - является классом, т.е. подкласс 

```ruby
irb(main):012:0> 1.is_a?(Object)
=> true
irb(main):013:0> 1.is_a?(Class)
=> false
irb(main):014:0> Object.is_a?(Class)
=> true
irb(main):015:0> Class.is_a?(Class)
=> true
irb(main):016:0>
```
```ruby
irb(main):001:0> Class.is_a?(Object)
=> true
```

>[!Question] Как относятся понятия
Объект и Класс?

String нельзя складывать с Integer, полагается - операция применима только к объектам одного класса. Чтобы применить операцию печати объекта класса String к чужеродному объекту (класса Integer), его нужно преобразовать, привести к классу String.  Т.е. изготовить небывалый ранее объект - строку высосанную из пальца, в процессе размышлений о числе. Эта высосанная из пальца ассоциация cугубо субъективна - так захотел программист.
```ruby
# приведение строки к числу, а числа к строке
irb(main):001:0> age=gets
33
=> "33\n"
irb(main):002:0> puts "Age is " + ( age.to_i * 12 ).to_s + " monthes."
Age is 396 monthes.
=> nil
```
>[!Note]
## Здравствуйте, я ваш REPL
Из начальных букв у нас получилось REPL — read evaluate print loop. То есть REPL — это такая программа, которая сначала читает, потом исполняет, потом печатает результат и затем начинает все сначала. Это понятие широко известно и используется не только в Руби. А в Руби REPL-программа называется irb (interactive ruby).

### Размер объекта

Объекту языка свойствена мера. Так объект типа String измеряется в символах:
```ruby
irb(main):014:0> "hello".size
=> 5
```

Объекту тип Integer свойственно имеряться в 8-и байтовых словах:
```ruby
# это число не вмещается в 64 бита:
irb(main):012:0> (2**64).size
=> 9
# ему нужно 9-ть слов
#
# а вот этому числу достаточно 8-и слов
irb(main):013:0> (2**63).size
=> 8
irb(main):009:0> 3.size
=> 8
# ... как и числу 3
```

### Интерполяция строк

Строки в двойных кавычках интерпретируются как символы печатной машинки - обычные и специальные (типа перевода каретки):
```ruby
irb(main):001:0> "Hello\n".chomp.size
=> 5
irb(main):002:0> "Hello".chomp.size
=> 5
```
Строки в одинарных кавычках для ruby - *не аналоговые*, не из печатной машинки, а *цифровые* - здесь нет понятия `специального символа`, здесь символы - это `байт`-ы:
```ruby
irb(main):003:0> 'Hello\n'.chomp.size
=> 7
```
##### Задание 2
>
X> Напишите программу для подсчета годовой зарплаты. Пользователь вводит размер заработной платы в месяц, а программа выводит размер заработной платы в год. Допустим, что пользователь каждый месяц хочет откладывать 15 % своей зарплаты. Измените программу, чтобы она выводила не только размер заработной платы, но и размер отложенных за год средств. Измените программу, чтобы она выводила размер отложенных средств за 5 лет.
```ruby
puts "Input your month income:"
inc_m=gets.to_f
puts "If put 15% isurance, then:"
inc_y=inc_m*12
insr_y=inc_y*15/100
puts "\tyear income is #{inc_y}"
puts "\tyears insurance #{insr_y}"
puts "\t5 year income is #{inc_y*5}"
puts "\t5 years insurance is #{insr_y*5}"
```
```terminal
Input your month income:
45000
If put 15% isurance, then:
        year income is 540000.0
        years insurance 81000.0
        5 year income is 2700000.0
        5 years insurance is 405000.0
```

#### Bang!

Язык - суть именование адресов на объекты памяти:
- Оъект - это физические выключатели в микросхеме памяти, составляющие единство. Это единство и есть объект языка.
- Имя, переменная - это слово в словаре - хэш-таблице из человеческих слов (имен переменных) и адресов объектов в памяти машины.
- Адрес - это логический элемент, атом древовидной логической конструкции:
    - физические элементы машины изготовлены по древовидному чертежу
    - умозрение программиста оперирует абстракциями по древовидному чертежу
    - производитель машин и программист руководствуются конвенцией, соглашением - давайте будем использовать общую логико-математическую теорию (целостную систему рассуждений) для нашей общей коммерческой выгоды

Оператор `Bang!` проявляет объективность объекта (физическое тело, единица) и субъективность программиста:
- программист может называть объект так, как ему `удобно`
- объект же остается единицей (но не множеством)
    - объект один, а имен - множество

> [!Attention] Коробочка со значением и ссылка. 
> Две коробочки и их отношение.
> [[Максим @demimurych|Гений эффективности]] о переменных: [Почему ООП умирает | Стрим про языки программирования с @AsForJS - YouTube](https://youtu.be/mxquElJC_qM?t=857)


```ruby
irb(main):001:0> obj_name_1="СоСТОЯние ЕдИНСТВа ВЫКлючателей В МИКросХЕМе ПАмяти"
=> "СоСТОЯние ЕдИНСТВа ВЫКлючателей В МИКросХЕМе ПАмяти"
irb(main):002:0> obj_name_2=obj_name_1
=> "СоСТОЯние ЕдИНСТВа ВЫКлючателей В МИКросХЕМе ПАмяти"
irb(main):003:0> # Все то же единство физических выключателей можем именовать
=> nil
irb(main):004:0> # по-другому, вторым именем
=> nil
irb(main):005:0> # Спросим абстракцию: Что у тебя за душой?
=> nil
irb(main):006:0> puts obj_name_1
СоСТОЯние ЕдИНСТВа ВЫКлючателей В МИКросХЕМе ПАмяти
=> nil
irb(main):007:0> # Изменение абстракции равно изменению физического атома? Абстрация физически полезна?
=> nil
irb(main):008:0> puts obj_name_1.downcase!
состояние единства выключателей в микросхеме памяти
=> nil
irb(main):009:0> # Полезна - изменение физического атома налицо.
=> nil
irb(main):010:0> # Вопрос вопросов о мышлении: А вот за вторым именем объекта что-то независимое от оъекта есть?
=> nil
irb(main):011:0> puts obj_name_2
состояние единства выключателей в микросхеме памяти
=> nil
irb(main):012:0> # Нет, за вторым именем нет ничего физически иного в физически атомном.
=> nil
```

>[!Question] Основной вопрос философии
>Как второе имя вещи влияет на вещь?
>
>Не замысел ли программиста приговаривает вещь. Программист - судьба вещи?


#### Оператор присваивания суть объективность

Объективность программирования является в операторе "=", *отношение созидания*
- оператор "=" полагает отношение
    - физического объекта
    - духовной деятельности - сфера имен и мечт
    - бракосочетание души программиста и физического голема из глины

Писатель знака "=" творит миф для голема. Имена - имена ролей, которые будет играть голем в пьесе писателя-программиста.

>
* Оператор присваивания `=` автоматически создаёт новый объект для переменной;
* одинаковых значений может быть множество;
* наименование каждой переменной уникально.
>[!Note] Сфера программирования
> Кажется, детонат, смысл, знак и символ - это и есть те
> понятия, которыми определяется деятельность пространства имен, пространство возможных пьес, сфера Витгенштейна.
> - [[lit/87.442 Модуль 1. Предмет логики]]
- [[lit/87.442 Модуль 2. Логика терминов]]
- [[Некоторые спорные размышления над работой Г. Фреге «Смысл и денотат»  Хабр]]

>https://docs.ruby-lang.org/en/master/String.html#method-i-chomp
>Some String methods modify self. Typically, a method whose name ends with ! modifies self and returns self; often a similarly named method (without the !) returns a new string.
>String#sub!: One substitution (or none); returns self.
>String#gsub!: Zero or more substitutions; returns self.
>>s = 'hello'
>>s.gsub(/[aeiou]/, '*') # => "h*ll*"
>>chomp!

#### Загадка о замороженном литерале

Наличие комментария в программе, влияет на ее результат. Почему?
```ruby
# frozen_string_literal: true
a='aaa'
b='aaa'
puts a.object_id
puts b.object_id
```
```terminal
# если комментарий есть, то вывод:
60
60
# если комментария нет, то вывод:
60
80
# если комментарий есть, но в нем вместо true указано false, то вывод:
60
80
```
- [ ] Значит, ruby понимает некторые коментарии как директивы
- [ ] директива frozen_... устанавливает единственность или множественность
объектов физических (в памяти, в микросхеме), создаваемых интерпретатором
при чтении текста программы. 
Что имел в виду программист, указывая в программе строку 'aaa' дважды?
- один физический оъект?
- два?

Директива frozen_... указывает на тип умостроя автора программы программе.

### Блок

Оператор применяется к блоку в фигурных скобках. Всякий (!) метод применим к блоку.
>[!Question] Блок - объект?
Почему блок универсален?

```ruby
loop { print 'Рома ' }
```

- [x] Блок - не объект, а некое прилагаемое лишь. Блок сам по себе существовать не может.

Объект Integer передает в блок параметр - число i:
```ruby
sum=0
12.times do |i|
  sum=sum+i
  puts "sum = #{sum} i = #{i}"
end
```
Т.о. блок вообще - это некое прилагаемое к методу объекта, нечто методное.
###### Задание 2
>
X> Измените программу из предыдущего задания со следующими условиями: человек берет дом не в рассрочку, а в кредит по ставке 4 % годовых на оставшуюся сумму. Для каждого года посчитайте, сколько денег нужно заплатить за этот год за использование кредита.
Измените программу из предыдущего задания со следующими условиями: человек берет дом не в рассрочку, а в кредит по ставке 4 % годовых на оставшуюся сумму. Для каждого года посчитайте, сколько денег нужно заплатить за этот год за использование кредита.
```ruby
cost=500000
irb(main):026:1* period.times do |i|
irb(main):027:1*   puts "конец #{i+1}-го года: %% #{cost*( 1 - i.to_f/period.to_f )*0.04}"
irb(main):028:0> end
```
###### Задание 3
>
X> Посчитайте количество денег (total), которые мы заплатим только в виде процентов по кредиту за 30 лет.
```ruby
irb(main):006:0> cost=500000
=> 500000
irb(main):007:0> sum_proc=0
=> 0
irb(main):008:0> period=30
=> 30
irb(main):009:1* period.times do |i|
irb(main):010:1*   sum_proc=sum_proc + cost*( 1 - i.to_f/period.to_f )*0.04
irb(main):011:1*   puts "конец #{i+1}-го года: %% #{sum_proc}"
irb(main):012:0> end
```

#### TrueClass и FalseClass

Знак вопроса в конце метода говорит лишь о том, что метод возвращает значение типа *Boolean* (в языке Руби нет отдельного типа для *Boolean*, поэтому это либо *TrueClass* тип, либо *FalseClass* тип). Другими словами, значение либо *true*, либо *false*. Например, метод, который определяет, беременна ли девушка, можно записать только со знаком вопроса в конце, потому что результат — или *true* (истина), или *false* (ложь). Часто такие методы начинаются со слова `is`:
```ruby
irb(main):002:0> (1.even?).class
=> FalseClass
irb(main):003:0> (1.odd?).class
=> TrueClass
irb(main):004:0>
```
Метод `even?` объекта `1` возвращает объект класса `FalseClass` - что означает *не принадлежать классу четных чисел*.
Результатом логического выражения является объект одного из двух классов, которые привычно ассоциируются с истиной и ложью:
```ruby
irb(main):001:0> 10%2==0
=> true
irb(main):002:0> 10%2!=0
=> false
irb(main):003:0> (10%2!=0).class
=> FalseClass
```
X> Вывести на экран числа от 50 до 100.
X> Вывести на экран числа от 50 до 100, и если число четное — рядом с ним написать `true`, если нечетное — `false`.
```ruby
irb(main):005:0> 50.upto(100) { |i| puts "#{i}" }
irb(main):004:0> 51.times { |i| puts "#{i+50}" }
```
Первое решение - буквальное выражение человеческого языка.
```ruby
irb(main):004:1* 50.upto(100) do|i|
irb(main):005:1*   puts "#{i} : " + "#{i.even?}"
irb(main):006:0> end
```
X> Вы создаете веб-сайт для барбер-шопа. Выведите на экран все виды текстурного крема для волос. Каждый вид крема имеет два параметра, SHINE (блеск) и HOLD (стойкость). Каждый параметр представлен цифрой от 1 до 5.
```ruby
irb(main):012:1* 1.upto(up_shine) do |i|
irb(main):013:2*   1.upto(up_hold) do |j|
irb(main):014:2*     puts "SHINE #{i} / HOLD #{j}"
irb(main):015:1*   end
irb(main):016:0> end
```

## Ветвление

X> Известно, что на Луне продают участки. Любой участок менее 50 квадратных метров стоит 1000 долларов. Участок площадью от 50 до 100 квадратных метров стоит 1500 долларов. От 100 и выше — по 25 долларов за квадратный метр. Напишите программу, которая запрашивает длину и ширину участка и выводит на экран его стоимость.
Известно, что на Луне продают участки. Любой участок менее 50 квадратных метров стоит 1000 долларов. Участок площадью от 50 до 100 квадратных метров стоит 1500 долларов. От 100 и выше — по 25 долларов за квадратный метр. Напишите программу, которая запрашивает длину и ширину участка и выводит на экран его стоимость.
```ruby
puts "Цена луны #{1000} if s<50"
puts "Цена луны #{1500} if s>50 && s<100"
puts "Цена луны #{25}*s if s>=100"

puts "Input width:"
w=gets.chomp.to_f
puts "Input length:"
l=gets.chomp.to_f
s=w*l
puts "Цена луны #{1000}" if s<50
puts "Цена луны #{1500}" if s>50 && s<100
puts "Цена луны #{25*s}" if s>=100
```
X> Напишите программу «иммигрант». Программа должна задавать следующие вопросы: «У вас есть высшее образование? (y/n)», «У вас есть опыт работы программистом? (y/n)», «У вас более трех лет опыта? (y/n)». За каждый положительный ответ начисляется 1 балл (переменную можно назвать score). Если набралось 2 или более баллов, программа должна выводить на экран «Добро пожаловать в США».
```ruby
score=0
puts "У вас есть высшее образование? (y/n)"
score=1 if gets.chomp.downcase == 'y'
puts "У вас есть опыт работы программистом? (y/n)"
score=score+1 if gets.chomp.downcase == 'y'
puts "У вас более трех лет опыта? (y/n)"
score=score+1 if gets.chomp.downcase == 'y'
puts "Добро пожаловать в США." if score >= 3
```
X> Измените программу, чтобы она загадывала число от 1 до 1_000_000 (1 миллиона). Чтобы можно было угадать это число, программа должна сравнивать текущий ответ пользователя и искомое число: 1) если ответ пользователя больше, то программа должна выводить на экран «Искомое число меньше вашего ответа»; 2) иначе «Искомое число больше вашего ответа». Может показаться, что угадать это число невозможно, однако математический расчет показывает, что угадать число в этом случае можно не более, чем за 20 попыток.
Напишите программу, чтобы она загадывала число от 1 до 1_000_000 (1 миллиона). Чтобы можно было угадать это число, программа должна сравнивать текущий ответ пользователя и искомое число: 1) если ответ пользователя больше, то программа должна выводить на экран «Искомое число меньше вашего ответа»; 2) иначе «Искомое число больше вашего ответа». Может показаться, что угадать это число невозможно, однако математический расчет показывает, что угадать число в этом случае можно не более, чем за 20 попыток.
```ruby
number=rand(1..1000000)
print 'Привет! Я загадал число от до 1000000, попробуйте угадать:'

loop do
  input=gets.to_i

  if input == number
    puts 'Правильно!'
    exit
  else
    if input > number
      print'Неправильно, искомое число меньше, попробуйте еще раз:'
    else
      print'Неправильно, искомое число больше, попробуйте еще раз:'
    end
  end
end
```
## Часть 3. Время веселья

### Тернарный оператор

